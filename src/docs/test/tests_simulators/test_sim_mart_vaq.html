<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>test.tests_simulators.test_sim_mart_vaq API documentation</title>
<meta name="description" content="Test if the simulation from Martinez-Vaquero is running correctly." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>test.tests_simulators.test_sim_mart_vaq</code></h1>
</header>
<section id="section-intro">
<p>Test if the simulation from Martinez-Vaquero is running correctly.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Test if the simulation from Martinez-Vaquero is running correctly.&#34;&#34;&#34;
from copy import deepcopy
from unittest import main

import graph_tool.all as gt
import numpy as np
import pytest
from hypothesis import assume
from hypothesis import given
from hypothesis import strategies as st
from simulators.sim_mart_vaq import SimMartVaq


class TestSimMartVaq:
    &#34;&#34;&#34;Class for unit tests for  SimMartVaq.&#34;&#34;&#34;

    @pytest.mark.essential
    def test_sim_mart_vaq(self, gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if the initialization works.&#34;&#34;&#34;
        org_size = gt_network.num_vertices()
        # Keep the ratio small so the test will be faster
        # by adding less nodes
        ratio_honest = 0.3
        ratio_wolf = 0.1

        simulators = SimMartVaq(gt_network, ratio_honest, ratio_wolf)

        # Test if the obj is init correctly
        assert isinstance(
            simulators, SimMartVaq
        ), &#34;Simulator hasn&#39;t been init correctly&#34;

        # Test if the ratio is caluclated correctly
        assert simulators.ratio_criminal == 0.6, &#34;Ratio is wrong.&#34;
        assert (
            simulators.n_criminal == org_size
        ), &#34;Determined number of criminals is wrong.&#34;
        assert simulators.total_number_nodes == 158, &#34;Ratio is wrong&#34;
        assert simulators.new_nodes == 63, &#34;Number of nodes to add is wrong&#34;
        assert (
            round(simulators.relative_ratio_honest, 2) == 0.75
        ), &#34;Relative ratio is wrong&#34;
        assert (
            round(simulators.relative_ratio_wolf, 2) == 0.25
        ), &#34;Relative ratio is wrong&#34;

        # Try to change its name
        with pytest.raises(Exception):
            simulators.name = &#34;New name&#34;

    @pytest.mark.essential
    def test_sim_mart_vaq_wrong_init(self, gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if a wrong init triggers the assert statements.&#34;&#34;&#34;
        # With ratio_honest == 0
        with pytest.raises(Exception):
            assert SimMartVaq(gt_network, ratio_honest=0)

        # With ratio_wolf == 1.1
        with pytest.raises(Exception):
            assert SimMartVaq(gt_network, ratio_wolf=1.1)

        # With ratios not adding up more than 1
        with pytest.raises(Exception):
            assert SimMartVaq(gt_network, ratio_honest=0.8, ratio_wolf=0.3)
            assert SimMartVaq(gt_network, ratio_honest=0.8, ratio_wolf=0.2)
            assert SimMartVaq(gt_network, ratio_honest=-0.8, ratio_wolf=0.1)
            assert SimMartVaq(gt_network, ratio_honest=-0.8, ratio_wolf=0.2)

    @pytest.mark.essential
    def test_initialise_network(self, gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if the init process is done corretly.

        More precisely tests if the ratio of c/h/w is correct
        &#34;&#34;&#34;
        simulators = SimMartVaq(gt_network, ratio_honest=0.2, ratio_wolf=0.3)
        network = simulators.initialise_network(simulators.network)

        # Criminal network size should be 95
        # Honest and Wolf ratio should be within a range given the init is stochastic
        assert (
            len(gt.find_vertex(network, network.vp.state, &#34;c&#34;)) == 95
        ), &#34;Criminal ratio not correct&#34;
        assert (
            38 - 15 &lt;= len(gt.find_vertex(network, network.vp.state, &#34;h&#34;)) &lt;= 38 + 15
        ), &#34;Honest ratio not correct&#34;
        assert (
            57 - 15 &lt;= len(gt.find_vertex(network, network.vp.state, &#34;w&#34;)) &lt;= 57 + 15
        ), &#34;Wolf ratio not correct&#34;

    @pytest.mark.essential
    def test_divide_in_groups(self, gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if the division into groups works correctly.&#34;&#34;&#34;
        ratio_honest = np.random.uniform(0.1, 0.99)
        ratio_wolf = np.random.uniform(0.1, (1 - 0.99))
        simulators = SimMartVaq(gt_network, ratio_honest, ratio_wolf)
        simulators.network = simulators.initialise_network(simulators.network)
        groups, groups_label = simulators.divide_in_groups(
            simulators.network, min_group=3
        )

        assert groups is not np.empty, &#34;Group list is empty&#34;
        assert all(
            [isinstance(item, int) for item in groups]
        ), &#34;Items in Group should be int&#34;
        assert isinstance(groups_label, frozenset), &#34;Group label should be frozenset&#34;
        assert len(groups_label) &gt; 0, &#34;Group label is empty&#34;
        assert all(
            [isinstance(item, int) for item in groups_label]
        ), &#34;Items in Group label should be int&#34;

    @pytest.mark.essential
    def test_act_divide_in_groups_faster(self, gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if the division into groups works correctly.&#34;&#34;&#34;
        ratio_honest = np.random.uniform(0.1, 0.80)
        ratio_wolf = np.random.uniform(0.1, (1 - 0.80))
        simulators = SimMartVaq(gt_network, ratio_honest, ratio_wolf)
        simulators.network = simulators.initialise_network(simulators.network)
        divided_network, n_groups = simulators.act_divide_in_groups_faster(
            simulators.network, min_grp=2, max_grp=2
        )

        # Group attribute needs to exist
        assert divided_network.vp.grp_nbr, &#34;Attribute grp_nbr doesn&#39;t exist....&#34;

        # Check if divided in two, every node should have a neighbour of the same group#
        # Pick random neighbors
        for i in range(0, 100):
            # Get random node
            x = np.random.uniform(1, divided_network.num_vertices())
            x_group = divided_network.vp.grp_nbr[divided_network.vertex(x)]
            neighbours = list(divided_network.iter_all_neighbors(x))
            neighbours_group = [
                divided_network.vp.grp_nbr[divided_network.vertex(neighbour)]
                for neighbour in neighbours
            ]
            assert x_group in neighbours_group, &#34;No neighbour is of the same group...&#34;

        # Check if recalled, the attributes are indeed reset
        # Set group number to avoid the chance to have same group number again
        divided_network_1, n_groups = simulators.act_divide_in_groups_faster(
            simulators.network, min_grp=100, max_grp=100
        )
        x_group_1 = divided_network_1.vp.grp_nbr[divided_network_1.vertex(25)]
        divided_network_2, n_groups = simulators.act_divide_in_groups_faster(
            divided_network_1, min_grp=100, max_grp=100
        )
        x_group_2 = divided_network_2.vp.grp_nbr[divided_network_2.vertex(25)]
        assert x_group_1 != x_group_2, &#34;Attributes are not reset correctly&#34;

    @pytest.mark.essential
    def test_act_divide_in_groups(self, gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if the division into groups works correctly.&#34;&#34;&#34;
        ratio_honest = np.random.uniform(0.1, 0.90)
        ratio_wolf = np.random.uniform(0.1, (1 - ratio_honest - 0.1))
        simulators = SimMartVaq(gt_network, ratio_honest, ratio_wolf)
        simulators.network = simulators.initialise_network(simulators.network)
        divided_network, n_groups = simulators.act_divide_in_groups(
            simulators.network, min_grp=2, max_grp=2
        )

        # Group attribute needs to exist
        assert divided_network.vp.grp_nbr, &#34;Attribute grp_nbr doesn&#39;t exist....&#34;

        # Check if divided in two, every node should have a neighbour of the same group#
        # Pick random neighbors
        for i in range(0, 100):
            # Get random node
            x = np.random.uniform(1, divided_network.num_vertices())
            x_group = divided_network.vp.grp_nbr[divided_network.vertex(x)]
            neighbours = list(divided_network.iter_all_neighbors(x))
            neighbours_group = [
                divided_network.vp.grp_nbr[divided_network.vertex(neighbour)]
                for neighbour in neighbours
            ]
            assert x_group in neighbours_group, &#34;No neighbour is of the same group...&#34;

        # Check if recalled, the attributes are indeed reset
        # Set group number to avoid the chance to have same group number again
        divided_network_1, n_groups = simulators.act_divide_in_groups(
            simulators.network, min_grp=100, max_grp=100
        )
        x_group_1 = divided_network_1.vp.grp_nbr[divided_network_1.vertex(25)]
        divided_network_2, n_groups = simulators.act_divide_in_groups(
            divided_network_1, min_grp=100, max_grp=100
        )
        x_group_2 = divided_network_2.vp.grp_nbr[divided_network_2.vertex(25)]
        assert x_group_1 != x_group_2, &#34;Attributes are not reset correctly&#34;

    @pytest.mark.essential
    def test_init_fitness(self, gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if the init of the fitness attribute is done correctly.&#34;&#34;&#34;
        simulators = SimMartVaq(gt_network)
        network = simulators.init_fitness(simulators.network)
        assert network.vp.fitness, &#34;Fitness attribute doesn&#39;t exists...&#34;

    @pytest.mark.essential
    def test_acting_stage(self, gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if the acting stage process is working correctly.&#34;&#34;&#34;
        # Set delta to 100 to make sure wolf will always act
        simulators = SimMartVaq(gt_network, ratio_wolf=0.2, ratio_honest=0.4, delta=100)
        network = simulators.init_fitness(simulators.network)
        network = simulators.initialise_network(network)
        # Network and network_aft_dmge are same object
        # To compare network create an independent copy
        untouched_network = deepcopy(network)
        min_grp = 5
        max_grp = 10

        dict_of_communities = simulators.select_multiple_communities(
            network=gt_network, radius=1, min_grp=min_grp, max_grp=max_grp
        )
        mbrs = dict_of_communities[min_grp]
        n_c, n_h, n_w, p_c, p_h, p_w = simulators.counting_status_proprotions(
            network=network, group_members=mbrs
        )

        # Select one group number from the all the numbers
        network_aft_dmge, slct_pers, slct_pers_status = simulators.acting_stage(
            network, mbrs
        )

        # select random node from group
        node = np.random.choice(list(mbrs), 1)
        if slct_pers_status == &#34;h&#34;:
            assert list(network_aft_dmge.vp.fitness) == list(
                untouched_network.vp.fitness
            ), &#34;Fitness should be unchanged...&#34;

        elif slct_pers_status == &#34;c&#34;:
            if network.vp.state[network.vertex(node)] == &#34;c&#34;:
                assert network_aft_dmge.vp.fitness[
                    network_aft_dmge.vertex(node)
                ] == untouched_network.vp.fitness[untouched_network.vertex(node)] + (
                    ((n_h + n_w) * (simulators.r_c * simulators.c_c)) / n_c
                )
            elif network.vp.state[network.vertex(node)] in [&#34;h&#34;, &#34;w&#34;]:
                assert network_aft_dmge.vp.fitness[
                    network_aft_dmge.vertex(node)
                ] == untouched_network.vp.fitness[untouched_network.vertex(node)] - (
                    simulators.r_c * simulators.c_c
                )

        elif slct_pers_status == &#34;w&#34;:
            if node == slct_pers:
                assert network_aft_dmge.vp.fitness[
                    network_aft_dmge.vertex(node)
                ] == untouched_network.vp.fitness[untouched_network.vertex(node)] + (
                    len(mbrs) - 1
                ) * (
                    simulators.r_w * simulators.c_w
                )
            else:
                if network_aft_dmge.vp.state[network_aft_dmge.vertex(node)] in [
                    &#34;h&#34;,
                    &#34;w&#34;,
                ]:
                    assert network_aft_dmge.vp.fitness[
                        network_aft_dmge.vertex(node)
                    ] == untouched_network.vp.fitness[
                        untouched_network.vertex(node)
                    ] - (
                        simulators.r_w * simulators.c_w
                    )
                elif network_aft_dmge.vp.state[network_aft_dmge.vertex(node)] == &#34;c&#34;:
                    assert network_aft_dmge.vp.fitness[
                        network_aft_dmge.vertex(node)
                    ] == untouched_network.vp.fitness[
                        untouched_network.vertex(node)
                    ] - (
                        simulators.r_w * simulators.c_w
                    ) + (
                        (
                            simulators.tau
                            * ((len(mbrs) - 1) * (simulators.r_w * simulators.c_w))
                        )
                        / n_c
                    )

                else:
                    raise KeyError(
                        f&#34;Node should have status w/c instead of \
                        {network_aft_dmge.vp.state[network_aft_dmge.vertex(node)]}&#34;
                    )

        else:
            assert slct_pers_status in [
                &#34;c&#34;,
                &#34;h&#34;,
                &#34;w&#34;,
            ], &#34;Returned status should be either c/h/w&#34;

    @pytest.mark.essential
    def test_acting_stage_2(self, gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if the acting stage process is working correclty.

        This time, lone wolf never act!
        &#34;&#34;&#34;
        # Set delta to 0 to make sure wolf will never act
        simulators = SimMartVaq(gt_network, ratio_wolf=0.2, ratio_honest=0.4, delta=0)
        network = simulators.init_fitness(simulators.network)
        network = simulators.initialise_network(network)
        # Network and network_aft_dmge are same object
        # To compare network create an independent copy
        untouched_network = deepcopy(network)
        min_grp = 5
        max_grp = 10

        dict_of_communities = simulators.select_multiple_communities(
            network=gt_network, radius=1, min_grp=min_grp, max_grp=max_grp
        )
        mbrs = dict_of_communities[min_grp]
        n_c, n_h, n_w, p_c, p_h, p_w = simulators.counting_status_proprotions(
            network=network, group_members=mbrs
        )

        # Select one group number from the all the numbers
        network_aft_dmge, slct_pers, slct_pers_status = simulators.acting_stage(
            network, mbrs
        )

        # select random node from group
        node = np.random.choice(list(mbrs), 1)
        if slct_pers_status == &#34;h&#34;:
            assert list(network_aft_dmge.vp.fitness) == list(
                untouched_network.vp.fitness
            ), &#34;Fitness should be unchanged...&#34;

        elif slct_pers_status == &#34;c&#34;:
            if network.vp.state[network.vertex(node)] == &#34;c&#34;:
                assert network_aft_dmge.vp.fitness[
                    network_aft_dmge.vertex(node)
                ] == untouched_network.vp.fitness[untouched_network.vertex(node)] + (
                    ((n_h + n_w) * (simulators.r_c * simulators.c_c)) / n_c
                )
            elif network.vp.state[network.vertex(node)] in [&#34;h&#34;, &#34;w&#34;]:
                assert network_aft_dmge.vp.fitness[
                    network_aft_dmge.vertex(node)
                ] == untouched_network.vp.fitness[untouched_network.vertex(node)] - (
                    simulators.r_c * simulators.c_c
                )

        elif slct_pers_status == &#34;w&#34;:
            assert list(network_aft_dmge.vp.fitness) == list(
                untouched_network.vp.fitness
            ), &#34;Fitness should be unchanged...&#34;

        else:
            assert slct_pers_status in [
                &#34;c&#34;,
                &#34;h&#34;,
                &#34;w&#34;,
            ], &#34;Returned status should be either c/h/w&#34;

    @pytest.mark.essential
    def test_select_communities(self, gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if the random select communites is working correctly.&#34;&#34;&#34;
        simulators = SimMartVaq(gt_network)
        network = simulators.init_fitness(simulators.network)

        # Depth 1
        seed = np.random.randint(0, gt_network.num_vertices())
        community = simulators.select_communities(network, radius=1, seed=seed)
        nbrs = network.iter_all_neighbors(seed)
        assert list(nbrs) != community

        # Depth 2
        seed = np.random.randint(0, gt_network.num_vertices())
        community = simulators.select_communities(network, radius=2, seed=seed)
        nbrs = list(network.iter_all_neighbors(seed))
        scnd_degree_nbr: list = []
        for nbr in nbrs:
            scnd_degree_nbr = scnd_degree_nbr + list(network.get_all_neighbors(nbr))

        nbrs = nbrs + scnd_degree_nbr
        assert set(nbrs) == community

        # Depth 3
        seed = np.random.randint(0, gt_network.num_vertices())
        community = simulators.select_communities(network, radius=3, seed=seed)
        nbrs = list(network.iter_all_neighbors(seed))
        scnd_degree_nbr = []
        for nbr in nbrs:
            scnd_degree_nbr = scnd_degree_nbr + list(network.get_all_neighbors(nbr))

        third_degree_nbr: list = []
        for nbr in scnd_degree_nbr:
            third_degree_nbr = third_degree_nbr + list(network.get_all_neighbors(nbr))

        nbrs = nbrs + scnd_degree_nbr + third_degree_nbr
        assert set(nbrs) == community

    @pytest.mark.essential
    def test_select_multiple_communities(self, gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if select_multiple_communities works correctly.&#34;&#34;&#34;
        simulators = SimMartVaq(gt_network)
        network = simulators.init_fitness(simulators.network)
        min_grp = 5
        max_grp = 10
        dict_of_communities = simulators.select_multiple_communities(
            network=network, radius=1, min_grp=min_grp, max_grp=max_grp
        )

        assert len(dict_of_communities) != 0, &#34;Dict of communities is empty...&#34;
        assert (
            min_grp &lt;= len(dict_of_communities) &lt;= max_grp
        ), &#34;Number of communites is not correct...&#34;

        for k, v in dict_of_communities.items():
            assert isinstance(k, int)
            assert len(dict_of_communities[k]) &gt;= 1, &#34;Some communities are empty...&#34;

    @pytest.mark.essential
    def test_counting_status_proportions(self, gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if the counting works correctly.&#34;&#34;&#34;
        simulators = SimMartVaq(gt_network)
        network = simulators.init_fitness(simulators.network)
        min_grp = 5
        max_grp = 10
        dict_of_communities = simulators.select_multiple_communities(
            network=network, radius=1, min_grp=min_grp, max_grp=max_grp
        )

        for k, v in dict_of_communities.items():
            n_h, n_c, n_w, p_c, p_h, p_w = simulators.counting_status_proprotions(
                network=network, group_members=v
            )

            assert 0 &lt;= p_c &lt;= 1, &#34;Proportion is not calculated correctly&#34;
            assert 0 &lt;= p_h &lt;= 1, &#34;Proportion is not calculated correctly&#34;
            assert 0 &lt;= p_w &lt;= 1, &#34;Proportion is not calculated correctly&#34;
            assert (
                pytest.approx(p_h + p_c + p_w, 0.1) == 1
            ), &#34;Total ratio should sum up to 1&#34;

            assert isinstance(n_h, int), &#34;Number should be an int&#34;
            assert isinstance(n_c, int), &#34;Number should be an int&#34;
            assert isinstance(n_w, int), &#34;Number should be an int&#34;
            assert n_h + n_c + n_w == len(v), &#34;Everyone should be c,h,w&#34;

    @pytest.mark.essential
    def test_get_overall_fitness_distribution(
        self, create_gt_network: gt.Graph
    ) -&gt; None:
        &#34;&#34;&#34;Test if the get overall fitness distribution works.&#34;&#34;&#34;
        simulators = SimMartVaq(network=create_gt_network)
        mean_h, mean_c, mean_w = simulators.get_overall_fitness_distribution(
            simulators.network, list(range(0, 5))
        )

        assert mean_h == 7, &#34;Mean fitness is not correct...&#34;
        assert mean_c == 10, &#34;Mean fitness is not correct...&#34;
        assert mean_w == 7, &#34;Mean fitness is not correct...&#34;

    @pytest.mark.essential
    def test_inflicting_damage(self, create_gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if the inflicting damage function works correclty.&#34;&#34;&#34;
        # set delta to 100 to make sure lone wolf acts
        simulators = SimMartVaq(
            create_gt_network, c_c=5, r_c=1, c_w=3, r_w=2, delta=100, tau=0.5
        )
        network = simulators.init_fitness(simulators.network)

        # What if the criminal is chosen
        node = 0
        network = simulators.inflict_damage(
            simulators.network,
            frozenset([0, 1, 2, 3, 4]),
            node,
            network.vp.state[network.vertex(node)],
        )
        assert network.vp.fitness[network.vertex(0)] == 30
        assert network.vp.fitness[network.vertex(2)] == 1
        assert network.vp.fitness[network.vertex(3)] == 6
        assert network.vp.fitness[network.vertex(4)] == -2

        # What if the criminal is chosen
        # Based on the previous fitness resulting from the criminal
        # activity above.
        node = 3
        network = simulators.inflict_damage(
            network,
            frozenset([0, 1, 2, 3, 4]),
            node,
            network.vp.state[network.vertex(node)],
        )
        assert network.vp.fitness[network.vertex(0)] == 36
        assert network.vp.fitness[network.vertex(2)] == -5
        assert network.vp.fitness[network.vertex(4)] == -8
        assert network.vp.fitness[network.vertex(3)] == 30

    @pytest.mark.essential
    def test_investigation_stage(self, create_gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if the investigation stage is working correctly.&#34;&#34;&#34;
        # Define the different penalties
        simulators = SimMartVaq(
            create_gt_network, gamma=0.5, beta_c=2, beta_s=3, beta_h=5
        )
        network = simulators.init_fitness(simulators.network)

        # What if the criminal is chosen
        # Triggers state and civilian punishment
        np.random.seed(2)
        node = 0
        network = simulators.investigation_stage(
            simulators.network,
            frozenset([0, 1, 2, 3, 4]),
            node,
            network.vp.state[network.vertex(node)],
        )
        assert network.vp.fitness[network.vertex(0)] == 5
        assert network.vp.fitness[network.vertex(1)] == 8
        assert network.vp.fitness[network.vertex(2)] == 6
        assert network.vp.fitness[network.vertex(3)] == 11
        assert network.vp.fitness[network.vertex(4)] == 3

        # What if the lone wolf is not chosen
        # Based on the previous fitness resulting from the criminal
        # activity above.
        np.random.seed(3)
        node = 3
        # Wolf did act
        simulators.wolf_acting = True
        network = simulators.investigation_stage(
            network,
            frozenset([0, 1, 2, 3, 4]),
            node,
            network.vp.state[network.vertex(node)],
        )
        assert network.vp.fitness[network.vertex(0)] == 5
        assert network.vp.fitness[network.vertex(1)] == 8
        assert network.vp.fitness[network.vertex(2)] == 6
        assert network.vp.fitness[network.vertex(3)] == 11
        assert network.vp.fitness[network.vertex(4)] == 3

        # What if the lone wolf is chosen
        # Based on the previous fitness resulting from the criminal
        # activity above.
        np.random.seed(6)
        node = 3
        # Wolf did act
        simulators.wolf_acting = True
        network = simulators.investigation_stage(
            network,
            frozenset([0, 1, 2, 3, 4]),
            node,
            network.vp.state[network.vertex(node)],
        )
        assert network.vp.fitness[network.vertex(0)] == 5
        assert network.vp.fitness[network.vertex(1)] == 8
        assert network.vp.fitness[network.vertex(2)] == 6
        assert network.vp.fitness[network.vertex(3)] == 10.6
        assert network.vp.fitness[network.vertex(4)] == 3

        # Check in case multiple criminals are present
        network.vp.state[network.vertex(4)] = &#34;c&#34;
        # Triggers state and civilian punishment
        np.random.seed(2)
        node = 0
        network = simulators.investigation_stage(
            simulators.network,
            frozenset([0, 1, 2, 3, 4]),
            node,
            network.vp.state[network.vertex(node)],
        )
        assert network.vp.fitness[network.vertex(0)] == 0
        assert network.vp.fitness[network.vertex(1)] == 8
        assert network.vp.fitness[network.vertex(2)] == 6
        assert network.vp.fitness[network.vertex(3)] == 10.6
        assert network.vp.fitness[network.vertex(4)] == 0.5

    @pytest.mark.essential
    def test_fermi_function(self, create_gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if the fermi function is working correclty.&#34;&#34;&#34;
        # The given network is just a placeholder
        simulators = SimMartVaq(create_gt_network)
        np.random.seed(0)
        assert simulators.fermi_function(40, 3), &#34;Should be True&#34;
        assert simulators.fermi_function(-40.1, 3) is False, &#34;Should be False&#34;

    @pytest.mark.essential
    @given(
        x=st.floats(allow_nan=False, allow_infinity=False),
        y=st.floats(allow_nan=False, allow_infinity=False),
        t=st.floats(allow_nan=False, allow_infinity=False),
    )
    def test_fermi_function_for_overflow(
        self, x: float, y: float, t: int, create_gt_network_session: gt.Graph
    ) -&gt; None:
        &#34;&#34;&#34;Test for fermi function if overflow still occurs.

        Hypothesis package is used to test random numbers
        &#34;&#34;&#34;
        assume(t != 0)
        simulators = SimMartVaq(create_gt_network_session, temperature=t)

        # Since it returns a bool anyway it will trigger the assert statements
        # But her the goal is to trigger an overflow in the equation
        try:
            simulators.fermi_function(x, y)
        except RuntimeError as e:
            raise Exception(f&#34;An error occurred with value {x},{y},{t}&#34;) from e

    @pytest.mark.essential
    def test_interchange_roles(self, create_gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if the interchanging role is working.&#34;&#34;&#34;
        simulators = SimMartVaq(create_gt_network, temperature=10)
        # Seed 2 will trigger that the roles are interchanged
        np.random.seed(2)
        network = simulators.interchange_roles(
            network=simulators.network, person_a=0, person_b=4
        )
        # Check if wolf turned criminal based on the criminal&#39;s fitness
        assert (
            network.vp.state[network.vertex(4)] == &#34;c&#34;
        ), &#34;Wolf didn&#39;t copied criminal....&#34;
        assert (
            network.vp.state[network.vertex(0)] == &#34;w&#34;
        ), &#34;Criminal didn&#39;t copied wolf....&#34;

    @pytest.mark.essential
    def test_mutation(self, create_gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if the mutation works correclty.&#34;&#34;&#34;
        simulators = SimMartVaq(create_gt_network, temperature=10)
        # The seed should turn nodes into a criminal,honest or wolf
        np.random.seed(0)
        node = 4
        network = simulators.mutation(simulators.network, person=node)
        assert (
            network.vp.state[network.vertex(node)] == &#34;c&#34;
        ), &#34;Mutation didn&#39;t work properly&#34;
        node = 0
        network = simulators.mutation(simulators.network, person=node)
        assert (
            network.vp.state[network.vertex(node)] == &#34;h&#34;
        ), &#34;Mutation didn&#39;t work properly&#34;
        node = 3
        network = simulators.mutation(simulators.network, person=node)
        assert (
            network.vp.state[network.vertex(node)] == &#34;c&#34;
        ), &#34;Mutation didn&#39;t work properly&#34;

    @pytest.mark.essential
    def test_evolutionary_stage(self, gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if the evolutionary stage is working correctly.&#34;&#34;&#34;
        simulators = SimMartVaq(
            gt_network, mutation_prob=0.3, temperature=10, ratio_honest=0.8
        )
        # Need to randomly change the fitness
        np.random.seed(0)
        network = simulators.initialise_network(simulators.network)
        network = simulators.init_fitness(simulators.network)
        np.random.seed(0)
        for i in range(0, network.num_vertices()):
            network.vp.fitness[network.vertex(i)] = np.random.randint(0, 200)

        # To compare it to the other object
        untouched_network = deepcopy(network)
        min_grp = 5
        max_grp = 10
        dict_of_communities = simulators.select_multiple_communities(
            network=network, radius=3, min_grp=min_grp, max_grp=max_grp
        )
        mbrs = dict_of_communities[min_grp]

        # Check if the players changed status
        # With seed 0, role interchange is triggered
        np.random.seed(0)
        network = simulators.evolutionary_stage(network, mbrs)

        assert (
            network.vp.state[network.vertex(74)]
            == untouched_network.vp.state[untouched_network.vertex(291)]
        ), &#34;Interchange function didn&#39;t work properly&#34;
        assert (
            network.vp.state[network.vertex(291)]
            == untouched_network.vp.state[untouched_network.vertex(291)]
        ), &#34;Interchange function didn&#39;t work properly&#34;

        # Check if the players changed status
        # With seed 5, mutation is triggered
        np.random.seed(10)
        network = simulators.evolutionary_stage(network, mbrs)
        assert (
            network.vp.state[network.vertex(515)] == &#34;c&#34;
        ), &#34;Mutation function didn&#39;t work properly&#34;

    @pytest.mark.essential
    def test_play(self, gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if the play function is working.&#34;&#34;&#34;
        # Play the simulation
        rounds = 50
        simulator = SimMartVaq(gt_network, ratio_honest=0.7, ratio_wolf=0.05)
        network, data_collector = simulator.play(simulator.network, rounds=rounds)

        # Check if the data_collectors collect at each round data
        assert (
            len(data_collector[&#34;ratio_honest&#34;]) == rounds
        ), &#34;Length of the collected data is not correct...&#34;
        assert (
            len(data_collector[&#34;ratio_wolf&#34;]) == rounds
        ), &#34;Length of the collected data is not correct...&#34;
        assert (
            len(data_collector[&#34;ratio_criminal&#34;]) == rounds
        ), &#34;Length of the collected data is not correct...&#34;
        assert (
            len(data_collector[&#34;fitness_honest&#34;]) == rounds
        ), &#34;Length of the collected data is not correct...&#34;
        assert (
            len(data_collector[&#34;fitness_criminal&#34;]) == rounds
        ), &#34;Length of the collected data is not correct...&#34;
        assert (
            len(data_collector[&#34;fitness_wolf&#34;]) == rounds
        ), &#34;Length of the collected data is not correct...&#34;

        # Check if the data does indeed changes, checks the simulation is working
        assert (
            len(set(data_collector[&#34;ratio_honest&#34;])) &gt; 1
        ), &#34;Collectors keep collecting same value...&#34;
        assert (
            len(set(data_collector[&#34;ratio_wolf&#34;])) &gt; 1
        ), &#34;Collectors keep collecting same value...&#34;
        assert (
            len(set(data_collector[&#34;ratio_criminal&#34;])) &gt; 1
        ), &#34;Collectors keep collecting same value...&#34;
        assert (
            len(set(data_collector[&#34;fitness_honest&#34;])) &gt; 1
        ), &#34;Collectors keep collecting same value...&#34;
        assert (
            len(set(data_collector[&#34;fitness_criminal&#34;])) &gt; 1
        ), &#34;Collectors keep collecting same value...&#34;
        assert (
            len(set(data_collector[&#34;fitness_wolf&#34;])) &gt; 1
        ), &#34;Collectors keep collecting same value...&#34;

    @pytest.mark.essential
    def test_avg_play(self, gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if the play function is working.&#34;&#34;&#34;
        # Play the simulation
        rounds = 20
        simulator = SimMartVaq(gt_network, ratio_honest=0.7, ratio_wolf=0.05)
        data = simulator.avg_play(simulator.network, rounds=rounds, repetition=5)

        assert &#34;mean_ratio_criminal&#34; in data.keys(), &#34;Key not found&#34;
        assert &#34;mean_ratio_honest&#34; in data.keys(), &#34;Key not found&#34;
        assert &#34;mean_ratio_wolf&#34; in data.keys(), &#34;Key not found&#34;
        assert &#34;std_ratio_criminal&#34; in data.keys(), &#34;Key not found&#34;
        assert &#34;std_ratio_honest&#34; in data.keys(), &#34;Key not found&#34;
        assert &#34;std_ratio_wolf&#34; in data.keys(), &#34;Key not found&#34;

        assert len(data[&#34;mean_ratio_criminal&#34;]) != 0, &#34;Key not found&#34;
        assert len(data[&#34;mean_ratio_honest&#34;]) != 0, &#34;Key not found&#34;
        assert len(data[&#34;mean_ratio_wolf&#34;]) != 0, &#34;Key not found&#34;
        assert len(data[&#34;std_ratio_criminal&#34;]) != 0, &#34;Key not found&#34;
        assert len(data[&#34;std_ratio_honest&#34;]) != 0, &#34;Key not found&#34;
        assert len(data[&#34;std_ratio_wolf&#34;]) != 0, &#34;Key not found&#34;

        sim_1 = data[&#34;0&#34;][&#34;ratio_criminal&#34;]
        sim_2 = data[&#34;2&#34;][&#34;ratio_criminal&#34;]
        assert not np.array_equal(
            np.array(sim_1), np.array(sim_2)
        ), &#34;Two simulations were identical....&#34;

    @pytest.mark.essential
    def test_scenario_1(self, gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test specific scenario.

        Test the scenario where no mutation happens and criminals
        have no benefits by acting but they act. Also wolfs do not act.
        Also no punish is conduced.
        So no change in the fitness is expected.
        &#34;&#34;&#34;
        simulators = SimMartVaq(
            network=gt_network,
            ratio_honest=0.45,
            ratio_wolf=0.45,
            delta=-10,  # no acting for wolfs
            gamma=0.5,
            tau=0,  # no fintess sharing between wolf to criminal
            beta_s=0,
            beta_h=0,
            beta_c=0,
            c_c=0,  # no benefits from criminals/ they still act
            r_c=10,
            c_w=10,
            r_w=10,
            mutation_prob=-0.1,  # only fermi function
        )
        _, data_collector = simulators.play(
            network=simulators.network, rounds=100, radius=3
        )

        # not any returns True if all element are False/0
        assert not any(
            data_collector[&#34;fitness_honest&#34;]
        ), &#34;Fitness should be zero all the time&#34;
        assert not any(
            data_collector[&#34;fitness_wolf&#34;]
        ), &#34;Fitness should be zero all the time&#34;
        assert not any(
            data_collector[&#34;fitness_criminal&#34;]
        ), &#34;Fitness should be zero all the time&#34;

    @pytest.mark.essential
    def test_hypergeometric_dist(self, create_gt_network_session: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if the hypergeometric_dict function is working.&#34;&#34;&#34;
        simulators = SimMartVaq(create_gt_network_session)
        assert (
            simulators.hypergeometric_dist(10, 5, 5, 15, 10, 10, 35, 20, &#34;x&#34;)
            == 0.10275099641829939
        )

    @pytest.mark.essential
    def test_mean_field_approx(self, create_gt_network_session: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if the mean_field_approx func works correctly using arbitrary arg.&#34;&#34;&#34;
        simulators = SimMartVaq(
            create_gt_network_session,
            c_c=2,
            r_c=4,
            c_w=5,
            r_w=7,
            delta=0.5,
            tau=4,
            gamma=2,
            beta_h=20,
            beta_s=32,
            beta_c=40,
        )

        mean_filed_approx = simulators.mean_field_approx(p_h=0.5, p_c=0.3, N=40, N_w=9)

        assert (
            pytest.approx(mean_filed_approx[&#34;h&#34;][&#34;a&#34;]) == -1.33125
        ), &#34;Value is not correct&#34;
        assert (
            pytest.approx(mean_filed_approx[&#34;c&#34;][&#34;a&#34;]) == 93.59375
        ), &#34;Value is not correct&#34;
        assert (
            pytest.approx(mean_filed_approx[&#34;w&#34;][&#34;a&#34;]) == -67.79375
        ), &#34;Value is not correct&#34;
        assert pytest.approx(mean_filed_approx[&#34;h&#34;][&#34;i&#34;]) == 0, &#34;Value is not correct&#34;
        assert (
            pytest.approx(mean_filed_approx[&#34;c&#34;][&#34;i&#34;]) == -7.245
        ), &#34;Value is not correct&#34;
        assert (
            pytest.approx(mean_filed_approx[&#34;w&#34;][&#34;i&#34;]) == -0.0219375
        ), &#34;Value is not correct&#34;

    @pytest.mark.essential
    def test_mean_field_approx_1(self, create_gt_network_session: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if the mean_field_approx func works correctly using arbitrary arg.

        The return value should be zero
        &#34;&#34;&#34;
        simulators = SimMartVaq(
            create_gt_network_session,
            c_c=0,
            r_c=4,
            c_w=0,
            r_w=7,
            delta=0.5,
            tau=4,
            gamma=2,
            beta_h=0,
            beta_s=0,
            beta_c=0,
        )
        mean_filed_approx = simulators.mean_field_approx(p_h=0.5, p_c=0.3, N=40, N_w=9)
        assert pytest.approx(mean_filed_approx[&#34;h&#34;][&#34;a&#34;]) == 0, &#34;Value is not correct&#34;
        assert pytest.approx(mean_filed_approx[&#34;c&#34;][&#34;a&#34;]) == 0, &#34;Value is not correct&#34;
        assert pytest.approx(mean_filed_approx[&#34;w&#34;][&#34;a&#34;]) == 0, &#34;Value is not correct&#34;
        assert pytest.approx(mean_filed_approx[&#34;h&#34;][&#34;i&#34;]) == 0, &#34;Value is not correct&#34;
        assert pytest.approx(mean_filed_approx[&#34;c&#34;][&#34;i&#34;]) == 0, &#34;Value is not correct&#34;
        assert pytest.approx(mean_filed_approx[&#34;w&#34;][&#34;i&#34;]) == 0, &#34;Value is not correct&#34;

    @pytest.mark.essential
    def test_get_analytical_solution(self, gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if get_analytical_solution works correctly.&#34;&#34;&#34;
        simulators = SimMartVaq(
            gt_network,
            ratio_honest=0.5,
            ratio_wolf=0.2,
            c_c=2,
            r_c=4,
            c_w=5,
            r_w=7,
            delta=0.5,
            tau=4,
            gamma=2,
            beta_h=20,
            beta_s=32,
            beta_c=40,
        )
        mean_fitness_dict = simulators.get_analytical_solution()

        assert mean_fitness_dict[&#34;h&#34;] != 0
        assert mean_fitness_dict[&#34;c&#34;] != 0
        assert mean_fitness_dict[&#34;w&#34;] != 0

        assert isinstance(mean_fitness_dict[&#34;h&#34;], float)
        assert isinstance(mean_fitness_dict[&#34;c&#34;], float)
        assert isinstance(mean_fitness_dict[&#34;w&#34;], float)

    @pytest.mark.essential
    def test_get_analytical_solution_1(self, gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if get_analytical_solution works correctly.

        The results should return a value of zero!
        &#34;&#34;&#34;
        simulators = SimMartVaq(
            gt_network,
            ratio_honest=0.5,
            ratio_wolf=0.2,
            c_c=0,
            r_c=4,
            c_w=0,
            r_w=7,
            delta=0.5,
            tau=4,
            gamma=2,
            beta_h=0,
            beta_s=0,
            beta_c=0,
        )
        mean_fitness_dict = simulators.get_analytical_solution()

        assert mean_fitness_dict[&#34;h&#34;] == 0
        assert mean_fitness_dict[&#34;c&#34;] == 0
        assert mean_fitness_dict[&#34;w&#34;] == 0

        assert isinstance(mean_fitness_dict[&#34;h&#34;], float)
        assert isinstance(mean_fitness_dict[&#34;c&#34;], float)
        assert isinstance(mean_fitness_dict[&#34;w&#34;], float)


if __name__ == &#34;__main__&#34;:
    main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq"><code class="flex name class">
<span>class <span class="ident">TestSimMartVaq</span></span>
</code></dt>
<dd>
<div class="desc"><p>Class for unit tests for
SimMartVaq.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TestSimMartVaq:
    &#34;&#34;&#34;Class for unit tests for  SimMartVaq.&#34;&#34;&#34;

    @pytest.mark.essential
    def test_sim_mart_vaq(self, gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if the initialization works.&#34;&#34;&#34;
        org_size = gt_network.num_vertices()
        # Keep the ratio small so the test will be faster
        # by adding less nodes
        ratio_honest = 0.3
        ratio_wolf = 0.1

        simulators = SimMartVaq(gt_network, ratio_honest, ratio_wolf)

        # Test if the obj is init correctly
        assert isinstance(
            simulators, SimMartVaq
        ), &#34;Simulator hasn&#39;t been init correctly&#34;

        # Test if the ratio is caluclated correctly
        assert simulators.ratio_criminal == 0.6, &#34;Ratio is wrong.&#34;
        assert (
            simulators.n_criminal == org_size
        ), &#34;Determined number of criminals is wrong.&#34;
        assert simulators.total_number_nodes == 158, &#34;Ratio is wrong&#34;
        assert simulators.new_nodes == 63, &#34;Number of nodes to add is wrong&#34;
        assert (
            round(simulators.relative_ratio_honest, 2) == 0.75
        ), &#34;Relative ratio is wrong&#34;
        assert (
            round(simulators.relative_ratio_wolf, 2) == 0.25
        ), &#34;Relative ratio is wrong&#34;

        # Try to change its name
        with pytest.raises(Exception):
            simulators.name = &#34;New name&#34;

    @pytest.mark.essential
    def test_sim_mart_vaq_wrong_init(self, gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if a wrong init triggers the assert statements.&#34;&#34;&#34;
        # With ratio_honest == 0
        with pytest.raises(Exception):
            assert SimMartVaq(gt_network, ratio_honest=0)

        # With ratio_wolf == 1.1
        with pytest.raises(Exception):
            assert SimMartVaq(gt_network, ratio_wolf=1.1)

        # With ratios not adding up more than 1
        with pytest.raises(Exception):
            assert SimMartVaq(gt_network, ratio_honest=0.8, ratio_wolf=0.3)
            assert SimMartVaq(gt_network, ratio_honest=0.8, ratio_wolf=0.2)
            assert SimMartVaq(gt_network, ratio_honest=-0.8, ratio_wolf=0.1)
            assert SimMartVaq(gt_network, ratio_honest=-0.8, ratio_wolf=0.2)

    @pytest.mark.essential
    def test_initialise_network(self, gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if the init process is done corretly.

        More precisely tests if the ratio of c/h/w is correct
        &#34;&#34;&#34;
        simulators = SimMartVaq(gt_network, ratio_honest=0.2, ratio_wolf=0.3)
        network = simulators.initialise_network(simulators.network)

        # Criminal network size should be 95
        # Honest and Wolf ratio should be within a range given the init is stochastic
        assert (
            len(gt.find_vertex(network, network.vp.state, &#34;c&#34;)) == 95
        ), &#34;Criminal ratio not correct&#34;
        assert (
            38 - 15 &lt;= len(gt.find_vertex(network, network.vp.state, &#34;h&#34;)) &lt;= 38 + 15
        ), &#34;Honest ratio not correct&#34;
        assert (
            57 - 15 &lt;= len(gt.find_vertex(network, network.vp.state, &#34;w&#34;)) &lt;= 57 + 15
        ), &#34;Wolf ratio not correct&#34;

    @pytest.mark.essential
    def test_divide_in_groups(self, gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if the division into groups works correctly.&#34;&#34;&#34;
        ratio_honest = np.random.uniform(0.1, 0.99)
        ratio_wolf = np.random.uniform(0.1, (1 - 0.99))
        simulators = SimMartVaq(gt_network, ratio_honest, ratio_wolf)
        simulators.network = simulators.initialise_network(simulators.network)
        groups, groups_label = simulators.divide_in_groups(
            simulators.network, min_group=3
        )

        assert groups is not np.empty, &#34;Group list is empty&#34;
        assert all(
            [isinstance(item, int) for item in groups]
        ), &#34;Items in Group should be int&#34;
        assert isinstance(groups_label, frozenset), &#34;Group label should be frozenset&#34;
        assert len(groups_label) &gt; 0, &#34;Group label is empty&#34;
        assert all(
            [isinstance(item, int) for item in groups_label]
        ), &#34;Items in Group label should be int&#34;

    @pytest.mark.essential
    def test_act_divide_in_groups_faster(self, gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if the division into groups works correctly.&#34;&#34;&#34;
        ratio_honest = np.random.uniform(0.1, 0.80)
        ratio_wolf = np.random.uniform(0.1, (1 - 0.80))
        simulators = SimMartVaq(gt_network, ratio_honest, ratio_wolf)
        simulators.network = simulators.initialise_network(simulators.network)
        divided_network, n_groups = simulators.act_divide_in_groups_faster(
            simulators.network, min_grp=2, max_grp=2
        )

        # Group attribute needs to exist
        assert divided_network.vp.grp_nbr, &#34;Attribute grp_nbr doesn&#39;t exist....&#34;

        # Check if divided in two, every node should have a neighbour of the same group#
        # Pick random neighbors
        for i in range(0, 100):
            # Get random node
            x = np.random.uniform(1, divided_network.num_vertices())
            x_group = divided_network.vp.grp_nbr[divided_network.vertex(x)]
            neighbours = list(divided_network.iter_all_neighbors(x))
            neighbours_group = [
                divided_network.vp.grp_nbr[divided_network.vertex(neighbour)]
                for neighbour in neighbours
            ]
            assert x_group in neighbours_group, &#34;No neighbour is of the same group...&#34;

        # Check if recalled, the attributes are indeed reset
        # Set group number to avoid the chance to have same group number again
        divided_network_1, n_groups = simulators.act_divide_in_groups_faster(
            simulators.network, min_grp=100, max_grp=100
        )
        x_group_1 = divided_network_1.vp.grp_nbr[divided_network_1.vertex(25)]
        divided_network_2, n_groups = simulators.act_divide_in_groups_faster(
            divided_network_1, min_grp=100, max_grp=100
        )
        x_group_2 = divided_network_2.vp.grp_nbr[divided_network_2.vertex(25)]
        assert x_group_1 != x_group_2, &#34;Attributes are not reset correctly&#34;

    @pytest.mark.essential
    def test_act_divide_in_groups(self, gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if the division into groups works correctly.&#34;&#34;&#34;
        ratio_honest = np.random.uniform(0.1, 0.90)
        ratio_wolf = np.random.uniform(0.1, (1 - ratio_honest - 0.1))
        simulators = SimMartVaq(gt_network, ratio_honest, ratio_wolf)
        simulators.network = simulators.initialise_network(simulators.network)
        divided_network, n_groups = simulators.act_divide_in_groups(
            simulators.network, min_grp=2, max_grp=2
        )

        # Group attribute needs to exist
        assert divided_network.vp.grp_nbr, &#34;Attribute grp_nbr doesn&#39;t exist....&#34;

        # Check if divided in two, every node should have a neighbour of the same group#
        # Pick random neighbors
        for i in range(0, 100):
            # Get random node
            x = np.random.uniform(1, divided_network.num_vertices())
            x_group = divided_network.vp.grp_nbr[divided_network.vertex(x)]
            neighbours = list(divided_network.iter_all_neighbors(x))
            neighbours_group = [
                divided_network.vp.grp_nbr[divided_network.vertex(neighbour)]
                for neighbour in neighbours
            ]
            assert x_group in neighbours_group, &#34;No neighbour is of the same group...&#34;

        # Check if recalled, the attributes are indeed reset
        # Set group number to avoid the chance to have same group number again
        divided_network_1, n_groups = simulators.act_divide_in_groups(
            simulators.network, min_grp=100, max_grp=100
        )
        x_group_1 = divided_network_1.vp.grp_nbr[divided_network_1.vertex(25)]
        divided_network_2, n_groups = simulators.act_divide_in_groups(
            divided_network_1, min_grp=100, max_grp=100
        )
        x_group_2 = divided_network_2.vp.grp_nbr[divided_network_2.vertex(25)]
        assert x_group_1 != x_group_2, &#34;Attributes are not reset correctly&#34;

    @pytest.mark.essential
    def test_init_fitness(self, gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if the init of the fitness attribute is done correctly.&#34;&#34;&#34;
        simulators = SimMartVaq(gt_network)
        network = simulators.init_fitness(simulators.network)
        assert network.vp.fitness, &#34;Fitness attribute doesn&#39;t exists...&#34;

    @pytest.mark.essential
    def test_acting_stage(self, gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if the acting stage process is working correctly.&#34;&#34;&#34;
        # Set delta to 100 to make sure wolf will always act
        simulators = SimMartVaq(gt_network, ratio_wolf=0.2, ratio_honest=0.4, delta=100)
        network = simulators.init_fitness(simulators.network)
        network = simulators.initialise_network(network)
        # Network and network_aft_dmge are same object
        # To compare network create an independent copy
        untouched_network = deepcopy(network)
        min_grp = 5
        max_grp = 10

        dict_of_communities = simulators.select_multiple_communities(
            network=gt_network, radius=1, min_grp=min_grp, max_grp=max_grp
        )
        mbrs = dict_of_communities[min_grp]
        n_c, n_h, n_w, p_c, p_h, p_w = simulators.counting_status_proprotions(
            network=network, group_members=mbrs
        )

        # Select one group number from the all the numbers
        network_aft_dmge, slct_pers, slct_pers_status = simulators.acting_stage(
            network, mbrs
        )

        # select random node from group
        node = np.random.choice(list(mbrs), 1)
        if slct_pers_status == &#34;h&#34;:
            assert list(network_aft_dmge.vp.fitness) == list(
                untouched_network.vp.fitness
            ), &#34;Fitness should be unchanged...&#34;

        elif slct_pers_status == &#34;c&#34;:
            if network.vp.state[network.vertex(node)] == &#34;c&#34;:
                assert network_aft_dmge.vp.fitness[
                    network_aft_dmge.vertex(node)
                ] == untouched_network.vp.fitness[untouched_network.vertex(node)] + (
                    ((n_h + n_w) * (simulators.r_c * simulators.c_c)) / n_c
                )
            elif network.vp.state[network.vertex(node)] in [&#34;h&#34;, &#34;w&#34;]:
                assert network_aft_dmge.vp.fitness[
                    network_aft_dmge.vertex(node)
                ] == untouched_network.vp.fitness[untouched_network.vertex(node)] - (
                    simulators.r_c * simulators.c_c
                )

        elif slct_pers_status == &#34;w&#34;:
            if node == slct_pers:
                assert network_aft_dmge.vp.fitness[
                    network_aft_dmge.vertex(node)
                ] == untouched_network.vp.fitness[untouched_network.vertex(node)] + (
                    len(mbrs) - 1
                ) * (
                    simulators.r_w * simulators.c_w
                )
            else:
                if network_aft_dmge.vp.state[network_aft_dmge.vertex(node)] in [
                    &#34;h&#34;,
                    &#34;w&#34;,
                ]:
                    assert network_aft_dmge.vp.fitness[
                        network_aft_dmge.vertex(node)
                    ] == untouched_network.vp.fitness[
                        untouched_network.vertex(node)
                    ] - (
                        simulators.r_w * simulators.c_w
                    )
                elif network_aft_dmge.vp.state[network_aft_dmge.vertex(node)] == &#34;c&#34;:
                    assert network_aft_dmge.vp.fitness[
                        network_aft_dmge.vertex(node)
                    ] == untouched_network.vp.fitness[
                        untouched_network.vertex(node)
                    ] - (
                        simulators.r_w * simulators.c_w
                    ) + (
                        (
                            simulators.tau
                            * ((len(mbrs) - 1) * (simulators.r_w * simulators.c_w))
                        )
                        / n_c
                    )

                else:
                    raise KeyError(
                        f&#34;Node should have status w/c instead of \
                        {network_aft_dmge.vp.state[network_aft_dmge.vertex(node)]}&#34;
                    )

        else:
            assert slct_pers_status in [
                &#34;c&#34;,
                &#34;h&#34;,
                &#34;w&#34;,
            ], &#34;Returned status should be either c/h/w&#34;

    @pytest.mark.essential
    def test_acting_stage_2(self, gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if the acting stage process is working correclty.

        This time, lone wolf never act!
        &#34;&#34;&#34;
        # Set delta to 0 to make sure wolf will never act
        simulators = SimMartVaq(gt_network, ratio_wolf=0.2, ratio_honest=0.4, delta=0)
        network = simulators.init_fitness(simulators.network)
        network = simulators.initialise_network(network)
        # Network and network_aft_dmge are same object
        # To compare network create an independent copy
        untouched_network = deepcopy(network)
        min_grp = 5
        max_grp = 10

        dict_of_communities = simulators.select_multiple_communities(
            network=gt_network, radius=1, min_grp=min_grp, max_grp=max_grp
        )
        mbrs = dict_of_communities[min_grp]
        n_c, n_h, n_w, p_c, p_h, p_w = simulators.counting_status_proprotions(
            network=network, group_members=mbrs
        )

        # Select one group number from the all the numbers
        network_aft_dmge, slct_pers, slct_pers_status = simulators.acting_stage(
            network, mbrs
        )

        # select random node from group
        node = np.random.choice(list(mbrs), 1)
        if slct_pers_status == &#34;h&#34;:
            assert list(network_aft_dmge.vp.fitness) == list(
                untouched_network.vp.fitness
            ), &#34;Fitness should be unchanged...&#34;

        elif slct_pers_status == &#34;c&#34;:
            if network.vp.state[network.vertex(node)] == &#34;c&#34;:
                assert network_aft_dmge.vp.fitness[
                    network_aft_dmge.vertex(node)
                ] == untouched_network.vp.fitness[untouched_network.vertex(node)] + (
                    ((n_h + n_w) * (simulators.r_c * simulators.c_c)) / n_c
                )
            elif network.vp.state[network.vertex(node)] in [&#34;h&#34;, &#34;w&#34;]:
                assert network_aft_dmge.vp.fitness[
                    network_aft_dmge.vertex(node)
                ] == untouched_network.vp.fitness[untouched_network.vertex(node)] - (
                    simulators.r_c * simulators.c_c
                )

        elif slct_pers_status == &#34;w&#34;:
            assert list(network_aft_dmge.vp.fitness) == list(
                untouched_network.vp.fitness
            ), &#34;Fitness should be unchanged...&#34;

        else:
            assert slct_pers_status in [
                &#34;c&#34;,
                &#34;h&#34;,
                &#34;w&#34;,
            ], &#34;Returned status should be either c/h/w&#34;

    @pytest.mark.essential
    def test_select_communities(self, gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if the random select communites is working correctly.&#34;&#34;&#34;
        simulators = SimMartVaq(gt_network)
        network = simulators.init_fitness(simulators.network)

        # Depth 1
        seed = np.random.randint(0, gt_network.num_vertices())
        community = simulators.select_communities(network, radius=1, seed=seed)
        nbrs = network.iter_all_neighbors(seed)
        assert list(nbrs) != community

        # Depth 2
        seed = np.random.randint(0, gt_network.num_vertices())
        community = simulators.select_communities(network, radius=2, seed=seed)
        nbrs = list(network.iter_all_neighbors(seed))
        scnd_degree_nbr: list = []
        for nbr in nbrs:
            scnd_degree_nbr = scnd_degree_nbr + list(network.get_all_neighbors(nbr))

        nbrs = nbrs + scnd_degree_nbr
        assert set(nbrs) == community

        # Depth 3
        seed = np.random.randint(0, gt_network.num_vertices())
        community = simulators.select_communities(network, radius=3, seed=seed)
        nbrs = list(network.iter_all_neighbors(seed))
        scnd_degree_nbr = []
        for nbr in nbrs:
            scnd_degree_nbr = scnd_degree_nbr + list(network.get_all_neighbors(nbr))

        third_degree_nbr: list = []
        for nbr in scnd_degree_nbr:
            third_degree_nbr = third_degree_nbr + list(network.get_all_neighbors(nbr))

        nbrs = nbrs + scnd_degree_nbr + third_degree_nbr
        assert set(nbrs) == community

    @pytest.mark.essential
    def test_select_multiple_communities(self, gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if select_multiple_communities works correctly.&#34;&#34;&#34;
        simulators = SimMartVaq(gt_network)
        network = simulators.init_fitness(simulators.network)
        min_grp = 5
        max_grp = 10
        dict_of_communities = simulators.select_multiple_communities(
            network=network, radius=1, min_grp=min_grp, max_grp=max_grp
        )

        assert len(dict_of_communities) != 0, &#34;Dict of communities is empty...&#34;
        assert (
            min_grp &lt;= len(dict_of_communities) &lt;= max_grp
        ), &#34;Number of communites is not correct...&#34;

        for k, v in dict_of_communities.items():
            assert isinstance(k, int)
            assert len(dict_of_communities[k]) &gt;= 1, &#34;Some communities are empty...&#34;

    @pytest.mark.essential
    def test_counting_status_proportions(self, gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if the counting works correctly.&#34;&#34;&#34;
        simulators = SimMartVaq(gt_network)
        network = simulators.init_fitness(simulators.network)
        min_grp = 5
        max_grp = 10
        dict_of_communities = simulators.select_multiple_communities(
            network=network, radius=1, min_grp=min_grp, max_grp=max_grp
        )

        for k, v in dict_of_communities.items():
            n_h, n_c, n_w, p_c, p_h, p_w = simulators.counting_status_proprotions(
                network=network, group_members=v
            )

            assert 0 &lt;= p_c &lt;= 1, &#34;Proportion is not calculated correctly&#34;
            assert 0 &lt;= p_h &lt;= 1, &#34;Proportion is not calculated correctly&#34;
            assert 0 &lt;= p_w &lt;= 1, &#34;Proportion is not calculated correctly&#34;
            assert (
                pytest.approx(p_h + p_c + p_w, 0.1) == 1
            ), &#34;Total ratio should sum up to 1&#34;

            assert isinstance(n_h, int), &#34;Number should be an int&#34;
            assert isinstance(n_c, int), &#34;Number should be an int&#34;
            assert isinstance(n_w, int), &#34;Number should be an int&#34;
            assert n_h + n_c + n_w == len(v), &#34;Everyone should be c,h,w&#34;

    @pytest.mark.essential
    def test_get_overall_fitness_distribution(
        self, create_gt_network: gt.Graph
    ) -&gt; None:
        &#34;&#34;&#34;Test if the get overall fitness distribution works.&#34;&#34;&#34;
        simulators = SimMartVaq(network=create_gt_network)
        mean_h, mean_c, mean_w = simulators.get_overall_fitness_distribution(
            simulators.network, list(range(0, 5))
        )

        assert mean_h == 7, &#34;Mean fitness is not correct...&#34;
        assert mean_c == 10, &#34;Mean fitness is not correct...&#34;
        assert mean_w == 7, &#34;Mean fitness is not correct...&#34;

    @pytest.mark.essential
    def test_inflicting_damage(self, create_gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if the inflicting damage function works correclty.&#34;&#34;&#34;
        # set delta to 100 to make sure lone wolf acts
        simulators = SimMartVaq(
            create_gt_network, c_c=5, r_c=1, c_w=3, r_w=2, delta=100, tau=0.5
        )
        network = simulators.init_fitness(simulators.network)

        # What if the criminal is chosen
        node = 0
        network = simulators.inflict_damage(
            simulators.network,
            frozenset([0, 1, 2, 3, 4]),
            node,
            network.vp.state[network.vertex(node)],
        )
        assert network.vp.fitness[network.vertex(0)] == 30
        assert network.vp.fitness[network.vertex(2)] == 1
        assert network.vp.fitness[network.vertex(3)] == 6
        assert network.vp.fitness[network.vertex(4)] == -2

        # What if the criminal is chosen
        # Based on the previous fitness resulting from the criminal
        # activity above.
        node = 3
        network = simulators.inflict_damage(
            network,
            frozenset([0, 1, 2, 3, 4]),
            node,
            network.vp.state[network.vertex(node)],
        )
        assert network.vp.fitness[network.vertex(0)] == 36
        assert network.vp.fitness[network.vertex(2)] == -5
        assert network.vp.fitness[network.vertex(4)] == -8
        assert network.vp.fitness[network.vertex(3)] == 30

    @pytest.mark.essential
    def test_investigation_stage(self, create_gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if the investigation stage is working correctly.&#34;&#34;&#34;
        # Define the different penalties
        simulators = SimMartVaq(
            create_gt_network, gamma=0.5, beta_c=2, beta_s=3, beta_h=5
        )
        network = simulators.init_fitness(simulators.network)

        # What if the criminal is chosen
        # Triggers state and civilian punishment
        np.random.seed(2)
        node = 0
        network = simulators.investigation_stage(
            simulators.network,
            frozenset([0, 1, 2, 3, 4]),
            node,
            network.vp.state[network.vertex(node)],
        )
        assert network.vp.fitness[network.vertex(0)] == 5
        assert network.vp.fitness[network.vertex(1)] == 8
        assert network.vp.fitness[network.vertex(2)] == 6
        assert network.vp.fitness[network.vertex(3)] == 11
        assert network.vp.fitness[network.vertex(4)] == 3

        # What if the lone wolf is not chosen
        # Based on the previous fitness resulting from the criminal
        # activity above.
        np.random.seed(3)
        node = 3
        # Wolf did act
        simulators.wolf_acting = True
        network = simulators.investigation_stage(
            network,
            frozenset([0, 1, 2, 3, 4]),
            node,
            network.vp.state[network.vertex(node)],
        )
        assert network.vp.fitness[network.vertex(0)] == 5
        assert network.vp.fitness[network.vertex(1)] == 8
        assert network.vp.fitness[network.vertex(2)] == 6
        assert network.vp.fitness[network.vertex(3)] == 11
        assert network.vp.fitness[network.vertex(4)] == 3

        # What if the lone wolf is chosen
        # Based on the previous fitness resulting from the criminal
        # activity above.
        np.random.seed(6)
        node = 3
        # Wolf did act
        simulators.wolf_acting = True
        network = simulators.investigation_stage(
            network,
            frozenset([0, 1, 2, 3, 4]),
            node,
            network.vp.state[network.vertex(node)],
        )
        assert network.vp.fitness[network.vertex(0)] == 5
        assert network.vp.fitness[network.vertex(1)] == 8
        assert network.vp.fitness[network.vertex(2)] == 6
        assert network.vp.fitness[network.vertex(3)] == 10.6
        assert network.vp.fitness[network.vertex(4)] == 3

        # Check in case multiple criminals are present
        network.vp.state[network.vertex(4)] = &#34;c&#34;
        # Triggers state and civilian punishment
        np.random.seed(2)
        node = 0
        network = simulators.investigation_stage(
            simulators.network,
            frozenset([0, 1, 2, 3, 4]),
            node,
            network.vp.state[network.vertex(node)],
        )
        assert network.vp.fitness[network.vertex(0)] == 0
        assert network.vp.fitness[network.vertex(1)] == 8
        assert network.vp.fitness[network.vertex(2)] == 6
        assert network.vp.fitness[network.vertex(3)] == 10.6
        assert network.vp.fitness[network.vertex(4)] == 0.5

    @pytest.mark.essential
    def test_fermi_function(self, create_gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if the fermi function is working correclty.&#34;&#34;&#34;
        # The given network is just a placeholder
        simulators = SimMartVaq(create_gt_network)
        np.random.seed(0)
        assert simulators.fermi_function(40, 3), &#34;Should be True&#34;
        assert simulators.fermi_function(-40.1, 3) is False, &#34;Should be False&#34;

    @pytest.mark.essential
    @given(
        x=st.floats(allow_nan=False, allow_infinity=False),
        y=st.floats(allow_nan=False, allow_infinity=False),
        t=st.floats(allow_nan=False, allow_infinity=False),
    )
    def test_fermi_function_for_overflow(
        self, x: float, y: float, t: int, create_gt_network_session: gt.Graph
    ) -&gt; None:
        &#34;&#34;&#34;Test for fermi function if overflow still occurs.

        Hypothesis package is used to test random numbers
        &#34;&#34;&#34;
        assume(t != 0)
        simulators = SimMartVaq(create_gt_network_session, temperature=t)

        # Since it returns a bool anyway it will trigger the assert statements
        # But her the goal is to trigger an overflow in the equation
        try:
            simulators.fermi_function(x, y)
        except RuntimeError as e:
            raise Exception(f&#34;An error occurred with value {x},{y},{t}&#34;) from e

    @pytest.mark.essential
    def test_interchange_roles(self, create_gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if the interchanging role is working.&#34;&#34;&#34;
        simulators = SimMartVaq(create_gt_network, temperature=10)
        # Seed 2 will trigger that the roles are interchanged
        np.random.seed(2)
        network = simulators.interchange_roles(
            network=simulators.network, person_a=0, person_b=4
        )
        # Check if wolf turned criminal based on the criminal&#39;s fitness
        assert (
            network.vp.state[network.vertex(4)] == &#34;c&#34;
        ), &#34;Wolf didn&#39;t copied criminal....&#34;
        assert (
            network.vp.state[network.vertex(0)] == &#34;w&#34;
        ), &#34;Criminal didn&#39;t copied wolf....&#34;

    @pytest.mark.essential
    def test_mutation(self, create_gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if the mutation works correclty.&#34;&#34;&#34;
        simulators = SimMartVaq(create_gt_network, temperature=10)
        # The seed should turn nodes into a criminal,honest or wolf
        np.random.seed(0)
        node = 4
        network = simulators.mutation(simulators.network, person=node)
        assert (
            network.vp.state[network.vertex(node)] == &#34;c&#34;
        ), &#34;Mutation didn&#39;t work properly&#34;
        node = 0
        network = simulators.mutation(simulators.network, person=node)
        assert (
            network.vp.state[network.vertex(node)] == &#34;h&#34;
        ), &#34;Mutation didn&#39;t work properly&#34;
        node = 3
        network = simulators.mutation(simulators.network, person=node)
        assert (
            network.vp.state[network.vertex(node)] == &#34;c&#34;
        ), &#34;Mutation didn&#39;t work properly&#34;

    @pytest.mark.essential
    def test_evolutionary_stage(self, gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if the evolutionary stage is working correctly.&#34;&#34;&#34;
        simulators = SimMartVaq(
            gt_network, mutation_prob=0.3, temperature=10, ratio_honest=0.8
        )
        # Need to randomly change the fitness
        np.random.seed(0)
        network = simulators.initialise_network(simulators.network)
        network = simulators.init_fitness(simulators.network)
        np.random.seed(0)
        for i in range(0, network.num_vertices()):
            network.vp.fitness[network.vertex(i)] = np.random.randint(0, 200)

        # To compare it to the other object
        untouched_network = deepcopy(network)
        min_grp = 5
        max_grp = 10
        dict_of_communities = simulators.select_multiple_communities(
            network=network, radius=3, min_grp=min_grp, max_grp=max_grp
        )
        mbrs = dict_of_communities[min_grp]

        # Check if the players changed status
        # With seed 0, role interchange is triggered
        np.random.seed(0)
        network = simulators.evolutionary_stage(network, mbrs)

        assert (
            network.vp.state[network.vertex(74)]
            == untouched_network.vp.state[untouched_network.vertex(291)]
        ), &#34;Interchange function didn&#39;t work properly&#34;
        assert (
            network.vp.state[network.vertex(291)]
            == untouched_network.vp.state[untouched_network.vertex(291)]
        ), &#34;Interchange function didn&#39;t work properly&#34;

        # Check if the players changed status
        # With seed 5, mutation is triggered
        np.random.seed(10)
        network = simulators.evolutionary_stage(network, mbrs)
        assert (
            network.vp.state[network.vertex(515)] == &#34;c&#34;
        ), &#34;Mutation function didn&#39;t work properly&#34;

    @pytest.mark.essential
    def test_play(self, gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if the play function is working.&#34;&#34;&#34;
        # Play the simulation
        rounds = 50
        simulator = SimMartVaq(gt_network, ratio_honest=0.7, ratio_wolf=0.05)
        network, data_collector = simulator.play(simulator.network, rounds=rounds)

        # Check if the data_collectors collect at each round data
        assert (
            len(data_collector[&#34;ratio_honest&#34;]) == rounds
        ), &#34;Length of the collected data is not correct...&#34;
        assert (
            len(data_collector[&#34;ratio_wolf&#34;]) == rounds
        ), &#34;Length of the collected data is not correct...&#34;
        assert (
            len(data_collector[&#34;ratio_criminal&#34;]) == rounds
        ), &#34;Length of the collected data is not correct...&#34;
        assert (
            len(data_collector[&#34;fitness_honest&#34;]) == rounds
        ), &#34;Length of the collected data is not correct...&#34;
        assert (
            len(data_collector[&#34;fitness_criminal&#34;]) == rounds
        ), &#34;Length of the collected data is not correct...&#34;
        assert (
            len(data_collector[&#34;fitness_wolf&#34;]) == rounds
        ), &#34;Length of the collected data is not correct...&#34;

        # Check if the data does indeed changes, checks the simulation is working
        assert (
            len(set(data_collector[&#34;ratio_honest&#34;])) &gt; 1
        ), &#34;Collectors keep collecting same value...&#34;
        assert (
            len(set(data_collector[&#34;ratio_wolf&#34;])) &gt; 1
        ), &#34;Collectors keep collecting same value...&#34;
        assert (
            len(set(data_collector[&#34;ratio_criminal&#34;])) &gt; 1
        ), &#34;Collectors keep collecting same value...&#34;
        assert (
            len(set(data_collector[&#34;fitness_honest&#34;])) &gt; 1
        ), &#34;Collectors keep collecting same value...&#34;
        assert (
            len(set(data_collector[&#34;fitness_criminal&#34;])) &gt; 1
        ), &#34;Collectors keep collecting same value...&#34;
        assert (
            len(set(data_collector[&#34;fitness_wolf&#34;])) &gt; 1
        ), &#34;Collectors keep collecting same value...&#34;

    @pytest.mark.essential
    def test_avg_play(self, gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if the play function is working.&#34;&#34;&#34;
        # Play the simulation
        rounds = 20
        simulator = SimMartVaq(gt_network, ratio_honest=0.7, ratio_wolf=0.05)
        data = simulator.avg_play(simulator.network, rounds=rounds, repetition=5)

        assert &#34;mean_ratio_criminal&#34; in data.keys(), &#34;Key not found&#34;
        assert &#34;mean_ratio_honest&#34; in data.keys(), &#34;Key not found&#34;
        assert &#34;mean_ratio_wolf&#34; in data.keys(), &#34;Key not found&#34;
        assert &#34;std_ratio_criminal&#34; in data.keys(), &#34;Key not found&#34;
        assert &#34;std_ratio_honest&#34; in data.keys(), &#34;Key not found&#34;
        assert &#34;std_ratio_wolf&#34; in data.keys(), &#34;Key not found&#34;

        assert len(data[&#34;mean_ratio_criminal&#34;]) != 0, &#34;Key not found&#34;
        assert len(data[&#34;mean_ratio_honest&#34;]) != 0, &#34;Key not found&#34;
        assert len(data[&#34;mean_ratio_wolf&#34;]) != 0, &#34;Key not found&#34;
        assert len(data[&#34;std_ratio_criminal&#34;]) != 0, &#34;Key not found&#34;
        assert len(data[&#34;std_ratio_honest&#34;]) != 0, &#34;Key not found&#34;
        assert len(data[&#34;std_ratio_wolf&#34;]) != 0, &#34;Key not found&#34;

        sim_1 = data[&#34;0&#34;][&#34;ratio_criminal&#34;]
        sim_2 = data[&#34;2&#34;][&#34;ratio_criminal&#34;]
        assert not np.array_equal(
            np.array(sim_1), np.array(sim_2)
        ), &#34;Two simulations were identical....&#34;

    @pytest.mark.essential
    def test_scenario_1(self, gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test specific scenario.

        Test the scenario where no mutation happens and criminals
        have no benefits by acting but they act. Also wolfs do not act.
        Also no punish is conduced.
        So no change in the fitness is expected.
        &#34;&#34;&#34;
        simulators = SimMartVaq(
            network=gt_network,
            ratio_honest=0.45,
            ratio_wolf=0.45,
            delta=-10,  # no acting for wolfs
            gamma=0.5,
            tau=0,  # no fintess sharing between wolf to criminal
            beta_s=0,
            beta_h=0,
            beta_c=0,
            c_c=0,  # no benefits from criminals/ they still act
            r_c=10,
            c_w=10,
            r_w=10,
            mutation_prob=-0.1,  # only fermi function
        )
        _, data_collector = simulators.play(
            network=simulators.network, rounds=100, radius=3
        )

        # not any returns True if all element are False/0
        assert not any(
            data_collector[&#34;fitness_honest&#34;]
        ), &#34;Fitness should be zero all the time&#34;
        assert not any(
            data_collector[&#34;fitness_wolf&#34;]
        ), &#34;Fitness should be zero all the time&#34;
        assert not any(
            data_collector[&#34;fitness_criminal&#34;]
        ), &#34;Fitness should be zero all the time&#34;

    @pytest.mark.essential
    def test_hypergeometric_dist(self, create_gt_network_session: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if the hypergeometric_dict function is working.&#34;&#34;&#34;
        simulators = SimMartVaq(create_gt_network_session)
        assert (
            simulators.hypergeometric_dist(10, 5, 5, 15, 10, 10, 35, 20, &#34;x&#34;)
            == 0.10275099641829939
        )

    @pytest.mark.essential
    def test_mean_field_approx(self, create_gt_network_session: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if the mean_field_approx func works correctly using arbitrary arg.&#34;&#34;&#34;
        simulators = SimMartVaq(
            create_gt_network_session,
            c_c=2,
            r_c=4,
            c_w=5,
            r_w=7,
            delta=0.5,
            tau=4,
            gamma=2,
            beta_h=20,
            beta_s=32,
            beta_c=40,
        )

        mean_filed_approx = simulators.mean_field_approx(p_h=0.5, p_c=0.3, N=40, N_w=9)

        assert (
            pytest.approx(mean_filed_approx[&#34;h&#34;][&#34;a&#34;]) == -1.33125
        ), &#34;Value is not correct&#34;
        assert (
            pytest.approx(mean_filed_approx[&#34;c&#34;][&#34;a&#34;]) == 93.59375
        ), &#34;Value is not correct&#34;
        assert (
            pytest.approx(mean_filed_approx[&#34;w&#34;][&#34;a&#34;]) == -67.79375
        ), &#34;Value is not correct&#34;
        assert pytest.approx(mean_filed_approx[&#34;h&#34;][&#34;i&#34;]) == 0, &#34;Value is not correct&#34;
        assert (
            pytest.approx(mean_filed_approx[&#34;c&#34;][&#34;i&#34;]) == -7.245
        ), &#34;Value is not correct&#34;
        assert (
            pytest.approx(mean_filed_approx[&#34;w&#34;][&#34;i&#34;]) == -0.0219375
        ), &#34;Value is not correct&#34;

    @pytest.mark.essential
    def test_mean_field_approx_1(self, create_gt_network_session: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if the mean_field_approx func works correctly using arbitrary arg.

        The return value should be zero
        &#34;&#34;&#34;
        simulators = SimMartVaq(
            create_gt_network_session,
            c_c=0,
            r_c=4,
            c_w=0,
            r_w=7,
            delta=0.5,
            tau=4,
            gamma=2,
            beta_h=0,
            beta_s=0,
            beta_c=0,
        )
        mean_filed_approx = simulators.mean_field_approx(p_h=0.5, p_c=0.3, N=40, N_w=9)
        assert pytest.approx(mean_filed_approx[&#34;h&#34;][&#34;a&#34;]) == 0, &#34;Value is not correct&#34;
        assert pytest.approx(mean_filed_approx[&#34;c&#34;][&#34;a&#34;]) == 0, &#34;Value is not correct&#34;
        assert pytest.approx(mean_filed_approx[&#34;w&#34;][&#34;a&#34;]) == 0, &#34;Value is not correct&#34;
        assert pytest.approx(mean_filed_approx[&#34;h&#34;][&#34;i&#34;]) == 0, &#34;Value is not correct&#34;
        assert pytest.approx(mean_filed_approx[&#34;c&#34;][&#34;i&#34;]) == 0, &#34;Value is not correct&#34;
        assert pytest.approx(mean_filed_approx[&#34;w&#34;][&#34;i&#34;]) == 0, &#34;Value is not correct&#34;

    @pytest.mark.essential
    def test_get_analytical_solution(self, gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if get_analytical_solution works correctly.&#34;&#34;&#34;
        simulators = SimMartVaq(
            gt_network,
            ratio_honest=0.5,
            ratio_wolf=0.2,
            c_c=2,
            r_c=4,
            c_w=5,
            r_w=7,
            delta=0.5,
            tau=4,
            gamma=2,
            beta_h=20,
            beta_s=32,
            beta_c=40,
        )
        mean_fitness_dict = simulators.get_analytical_solution()

        assert mean_fitness_dict[&#34;h&#34;] != 0
        assert mean_fitness_dict[&#34;c&#34;] != 0
        assert mean_fitness_dict[&#34;w&#34;] != 0

        assert isinstance(mean_fitness_dict[&#34;h&#34;], float)
        assert isinstance(mean_fitness_dict[&#34;c&#34;], float)
        assert isinstance(mean_fitness_dict[&#34;w&#34;], float)

    @pytest.mark.essential
    def test_get_analytical_solution_1(self, gt_network: gt.Graph) -&gt; None:
        &#34;&#34;&#34;Test if get_analytical_solution works correctly.

        The results should return a value of zero!
        &#34;&#34;&#34;
        simulators = SimMartVaq(
            gt_network,
            ratio_honest=0.5,
            ratio_wolf=0.2,
            c_c=0,
            r_c=4,
            c_w=0,
            r_w=7,
            delta=0.5,
            tau=4,
            gamma=2,
            beta_h=0,
            beta_s=0,
            beta_c=0,
        )
        mean_fitness_dict = simulators.get_analytical_solution()

        assert mean_fitness_dict[&#34;h&#34;] == 0
        assert mean_fitness_dict[&#34;c&#34;] == 0
        assert mean_fitness_dict[&#34;w&#34;] == 0

        assert isinstance(mean_fitness_dict[&#34;h&#34;], float)
        assert isinstance(mean_fitness_dict[&#34;c&#34;], float)
        assert isinstance(mean_fitness_dict[&#34;w&#34;], float)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_act_divide_in_groups"><code class="name flex">
<span>def <span class="ident">test_act_divide_in_groups</span></span>(<span>self, gt_network: graph_tool.Graph) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Test if the division into groups works correctly.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.essential
def test_act_divide_in_groups(self, gt_network: gt.Graph) -&gt; None:
    &#34;&#34;&#34;Test if the division into groups works correctly.&#34;&#34;&#34;
    ratio_honest = np.random.uniform(0.1, 0.90)
    ratio_wolf = np.random.uniform(0.1, (1 - ratio_honest - 0.1))
    simulators = SimMartVaq(gt_network, ratio_honest, ratio_wolf)
    simulators.network = simulators.initialise_network(simulators.network)
    divided_network, n_groups = simulators.act_divide_in_groups(
        simulators.network, min_grp=2, max_grp=2
    )

    # Group attribute needs to exist
    assert divided_network.vp.grp_nbr, &#34;Attribute grp_nbr doesn&#39;t exist....&#34;

    # Check if divided in two, every node should have a neighbour of the same group#
    # Pick random neighbors
    for i in range(0, 100):
        # Get random node
        x = np.random.uniform(1, divided_network.num_vertices())
        x_group = divided_network.vp.grp_nbr[divided_network.vertex(x)]
        neighbours = list(divided_network.iter_all_neighbors(x))
        neighbours_group = [
            divided_network.vp.grp_nbr[divided_network.vertex(neighbour)]
            for neighbour in neighbours
        ]
        assert x_group in neighbours_group, &#34;No neighbour is of the same group...&#34;

    # Check if recalled, the attributes are indeed reset
    # Set group number to avoid the chance to have same group number again
    divided_network_1, n_groups = simulators.act_divide_in_groups(
        simulators.network, min_grp=100, max_grp=100
    )
    x_group_1 = divided_network_1.vp.grp_nbr[divided_network_1.vertex(25)]
    divided_network_2, n_groups = simulators.act_divide_in_groups(
        divided_network_1, min_grp=100, max_grp=100
    )
    x_group_2 = divided_network_2.vp.grp_nbr[divided_network_2.vertex(25)]
    assert x_group_1 != x_group_2, &#34;Attributes are not reset correctly&#34;</code></pre>
</details>
</dd>
<dt id="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_act_divide_in_groups_faster"><code class="name flex">
<span>def <span class="ident">test_act_divide_in_groups_faster</span></span>(<span>self, gt_network: graph_tool.Graph) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Test if the division into groups works correctly.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.essential
def test_act_divide_in_groups_faster(self, gt_network: gt.Graph) -&gt; None:
    &#34;&#34;&#34;Test if the division into groups works correctly.&#34;&#34;&#34;
    ratio_honest = np.random.uniform(0.1, 0.80)
    ratio_wolf = np.random.uniform(0.1, (1 - 0.80))
    simulators = SimMartVaq(gt_network, ratio_honest, ratio_wolf)
    simulators.network = simulators.initialise_network(simulators.network)
    divided_network, n_groups = simulators.act_divide_in_groups_faster(
        simulators.network, min_grp=2, max_grp=2
    )

    # Group attribute needs to exist
    assert divided_network.vp.grp_nbr, &#34;Attribute grp_nbr doesn&#39;t exist....&#34;

    # Check if divided in two, every node should have a neighbour of the same group#
    # Pick random neighbors
    for i in range(0, 100):
        # Get random node
        x = np.random.uniform(1, divided_network.num_vertices())
        x_group = divided_network.vp.grp_nbr[divided_network.vertex(x)]
        neighbours = list(divided_network.iter_all_neighbors(x))
        neighbours_group = [
            divided_network.vp.grp_nbr[divided_network.vertex(neighbour)]
            for neighbour in neighbours
        ]
        assert x_group in neighbours_group, &#34;No neighbour is of the same group...&#34;

    # Check if recalled, the attributes are indeed reset
    # Set group number to avoid the chance to have same group number again
    divided_network_1, n_groups = simulators.act_divide_in_groups_faster(
        simulators.network, min_grp=100, max_grp=100
    )
    x_group_1 = divided_network_1.vp.grp_nbr[divided_network_1.vertex(25)]
    divided_network_2, n_groups = simulators.act_divide_in_groups_faster(
        divided_network_1, min_grp=100, max_grp=100
    )
    x_group_2 = divided_network_2.vp.grp_nbr[divided_network_2.vertex(25)]
    assert x_group_1 != x_group_2, &#34;Attributes are not reset correctly&#34;</code></pre>
</details>
</dd>
<dt id="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_acting_stage"><code class="name flex">
<span>def <span class="ident">test_acting_stage</span></span>(<span>self, gt_network: graph_tool.Graph) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Test if the acting stage process is working correctly.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.essential
def test_acting_stage(self, gt_network: gt.Graph) -&gt; None:
    &#34;&#34;&#34;Test if the acting stage process is working correctly.&#34;&#34;&#34;
    # Set delta to 100 to make sure wolf will always act
    simulators = SimMartVaq(gt_network, ratio_wolf=0.2, ratio_honest=0.4, delta=100)
    network = simulators.init_fitness(simulators.network)
    network = simulators.initialise_network(network)
    # Network and network_aft_dmge are same object
    # To compare network create an independent copy
    untouched_network = deepcopy(network)
    min_grp = 5
    max_grp = 10

    dict_of_communities = simulators.select_multiple_communities(
        network=gt_network, radius=1, min_grp=min_grp, max_grp=max_grp
    )
    mbrs = dict_of_communities[min_grp]
    n_c, n_h, n_w, p_c, p_h, p_w = simulators.counting_status_proprotions(
        network=network, group_members=mbrs
    )

    # Select one group number from the all the numbers
    network_aft_dmge, slct_pers, slct_pers_status = simulators.acting_stage(
        network, mbrs
    )

    # select random node from group
    node = np.random.choice(list(mbrs), 1)
    if slct_pers_status == &#34;h&#34;:
        assert list(network_aft_dmge.vp.fitness) == list(
            untouched_network.vp.fitness
        ), &#34;Fitness should be unchanged...&#34;

    elif slct_pers_status == &#34;c&#34;:
        if network.vp.state[network.vertex(node)] == &#34;c&#34;:
            assert network_aft_dmge.vp.fitness[
                network_aft_dmge.vertex(node)
            ] == untouched_network.vp.fitness[untouched_network.vertex(node)] + (
                ((n_h + n_w) * (simulators.r_c * simulators.c_c)) / n_c
            )
        elif network.vp.state[network.vertex(node)] in [&#34;h&#34;, &#34;w&#34;]:
            assert network_aft_dmge.vp.fitness[
                network_aft_dmge.vertex(node)
            ] == untouched_network.vp.fitness[untouched_network.vertex(node)] - (
                simulators.r_c * simulators.c_c
            )

    elif slct_pers_status == &#34;w&#34;:
        if node == slct_pers:
            assert network_aft_dmge.vp.fitness[
                network_aft_dmge.vertex(node)
            ] == untouched_network.vp.fitness[untouched_network.vertex(node)] + (
                len(mbrs) - 1
            ) * (
                simulators.r_w * simulators.c_w
            )
        else:
            if network_aft_dmge.vp.state[network_aft_dmge.vertex(node)] in [
                &#34;h&#34;,
                &#34;w&#34;,
            ]:
                assert network_aft_dmge.vp.fitness[
                    network_aft_dmge.vertex(node)
                ] == untouched_network.vp.fitness[
                    untouched_network.vertex(node)
                ] - (
                    simulators.r_w * simulators.c_w
                )
            elif network_aft_dmge.vp.state[network_aft_dmge.vertex(node)] == &#34;c&#34;:
                assert network_aft_dmge.vp.fitness[
                    network_aft_dmge.vertex(node)
                ] == untouched_network.vp.fitness[
                    untouched_network.vertex(node)
                ] - (
                    simulators.r_w * simulators.c_w
                ) + (
                    (
                        simulators.tau
                        * ((len(mbrs) - 1) * (simulators.r_w * simulators.c_w))
                    )
                    / n_c
                )

            else:
                raise KeyError(
                    f&#34;Node should have status w/c instead of \
                    {network_aft_dmge.vp.state[network_aft_dmge.vertex(node)]}&#34;
                )

    else:
        assert slct_pers_status in [
            &#34;c&#34;,
            &#34;h&#34;,
            &#34;w&#34;,
        ], &#34;Returned status should be either c/h/w&#34;</code></pre>
</details>
</dd>
<dt id="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_acting_stage_2"><code class="name flex">
<span>def <span class="ident">test_acting_stage_2</span></span>(<span>self, gt_network: graph_tool.Graph) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Test if the acting stage process is working correclty.</p>
<p>This time, lone wolf never act!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.essential
def test_acting_stage_2(self, gt_network: gt.Graph) -&gt; None:
    &#34;&#34;&#34;Test if the acting stage process is working correclty.

    This time, lone wolf never act!
    &#34;&#34;&#34;
    # Set delta to 0 to make sure wolf will never act
    simulators = SimMartVaq(gt_network, ratio_wolf=0.2, ratio_honest=0.4, delta=0)
    network = simulators.init_fitness(simulators.network)
    network = simulators.initialise_network(network)
    # Network and network_aft_dmge are same object
    # To compare network create an independent copy
    untouched_network = deepcopy(network)
    min_grp = 5
    max_grp = 10

    dict_of_communities = simulators.select_multiple_communities(
        network=gt_network, radius=1, min_grp=min_grp, max_grp=max_grp
    )
    mbrs = dict_of_communities[min_grp]
    n_c, n_h, n_w, p_c, p_h, p_w = simulators.counting_status_proprotions(
        network=network, group_members=mbrs
    )

    # Select one group number from the all the numbers
    network_aft_dmge, slct_pers, slct_pers_status = simulators.acting_stage(
        network, mbrs
    )

    # select random node from group
    node = np.random.choice(list(mbrs), 1)
    if slct_pers_status == &#34;h&#34;:
        assert list(network_aft_dmge.vp.fitness) == list(
            untouched_network.vp.fitness
        ), &#34;Fitness should be unchanged...&#34;

    elif slct_pers_status == &#34;c&#34;:
        if network.vp.state[network.vertex(node)] == &#34;c&#34;:
            assert network_aft_dmge.vp.fitness[
                network_aft_dmge.vertex(node)
            ] == untouched_network.vp.fitness[untouched_network.vertex(node)] + (
                ((n_h + n_w) * (simulators.r_c * simulators.c_c)) / n_c
            )
        elif network.vp.state[network.vertex(node)] in [&#34;h&#34;, &#34;w&#34;]:
            assert network_aft_dmge.vp.fitness[
                network_aft_dmge.vertex(node)
            ] == untouched_network.vp.fitness[untouched_network.vertex(node)] - (
                simulators.r_c * simulators.c_c
            )

    elif slct_pers_status == &#34;w&#34;:
        assert list(network_aft_dmge.vp.fitness) == list(
            untouched_network.vp.fitness
        ), &#34;Fitness should be unchanged...&#34;

    else:
        assert slct_pers_status in [
            &#34;c&#34;,
            &#34;h&#34;,
            &#34;w&#34;,
        ], &#34;Returned status should be either c/h/w&#34;</code></pre>
</details>
</dd>
<dt id="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_avg_play"><code class="name flex">
<span>def <span class="ident">test_avg_play</span></span>(<span>self, gt_network: graph_tool.Graph) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Test if the play function is working.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.essential
def test_avg_play(self, gt_network: gt.Graph) -&gt; None:
    &#34;&#34;&#34;Test if the play function is working.&#34;&#34;&#34;
    # Play the simulation
    rounds = 20
    simulator = SimMartVaq(gt_network, ratio_honest=0.7, ratio_wolf=0.05)
    data = simulator.avg_play(simulator.network, rounds=rounds, repetition=5)

    assert &#34;mean_ratio_criminal&#34; in data.keys(), &#34;Key not found&#34;
    assert &#34;mean_ratio_honest&#34; in data.keys(), &#34;Key not found&#34;
    assert &#34;mean_ratio_wolf&#34; in data.keys(), &#34;Key not found&#34;
    assert &#34;std_ratio_criminal&#34; in data.keys(), &#34;Key not found&#34;
    assert &#34;std_ratio_honest&#34; in data.keys(), &#34;Key not found&#34;
    assert &#34;std_ratio_wolf&#34; in data.keys(), &#34;Key not found&#34;

    assert len(data[&#34;mean_ratio_criminal&#34;]) != 0, &#34;Key not found&#34;
    assert len(data[&#34;mean_ratio_honest&#34;]) != 0, &#34;Key not found&#34;
    assert len(data[&#34;mean_ratio_wolf&#34;]) != 0, &#34;Key not found&#34;
    assert len(data[&#34;std_ratio_criminal&#34;]) != 0, &#34;Key not found&#34;
    assert len(data[&#34;std_ratio_honest&#34;]) != 0, &#34;Key not found&#34;
    assert len(data[&#34;std_ratio_wolf&#34;]) != 0, &#34;Key not found&#34;

    sim_1 = data[&#34;0&#34;][&#34;ratio_criminal&#34;]
    sim_2 = data[&#34;2&#34;][&#34;ratio_criminal&#34;]
    assert not np.array_equal(
        np.array(sim_1), np.array(sim_2)
    ), &#34;Two simulations were identical....&#34;</code></pre>
</details>
</dd>
<dt id="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_counting_status_proportions"><code class="name flex">
<span>def <span class="ident">test_counting_status_proportions</span></span>(<span>self, gt_network: graph_tool.Graph) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Test if the counting works correctly.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.essential
def test_counting_status_proportions(self, gt_network: gt.Graph) -&gt; None:
    &#34;&#34;&#34;Test if the counting works correctly.&#34;&#34;&#34;
    simulators = SimMartVaq(gt_network)
    network = simulators.init_fitness(simulators.network)
    min_grp = 5
    max_grp = 10
    dict_of_communities = simulators.select_multiple_communities(
        network=network, radius=1, min_grp=min_grp, max_grp=max_grp
    )

    for k, v in dict_of_communities.items():
        n_h, n_c, n_w, p_c, p_h, p_w = simulators.counting_status_proprotions(
            network=network, group_members=v
        )

        assert 0 &lt;= p_c &lt;= 1, &#34;Proportion is not calculated correctly&#34;
        assert 0 &lt;= p_h &lt;= 1, &#34;Proportion is not calculated correctly&#34;
        assert 0 &lt;= p_w &lt;= 1, &#34;Proportion is not calculated correctly&#34;
        assert (
            pytest.approx(p_h + p_c + p_w, 0.1) == 1
        ), &#34;Total ratio should sum up to 1&#34;

        assert isinstance(n_h, int), &#34;Number should be an int&#34;
        assert isinstance(n_c, int), &#34;Number should be an int&#34;
        assert isinstance(n_w, int), &#34;Number should be an int&#34;
        assert n_h + n_c + n_w == len(v), &#34;Everyone should be c,h,w&#34;</code></pre>
</details>
</dd>
<dt id="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_divide_in_groups"><code class="name flex">
<span>def <span class="ident">test_divide_in_groups</span></span>(<span>self, gt_network: graph_tool.Graph) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Test if the division into groups works correctly.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.essential
def test_divide_in_groups(self, gt_network: gt.Graph) -&gt; None:
    &#34;&#34;&#34;Test if the division into groups works correctly.&#34;&#34;&#34;
    ratio_honest = np.random.uniform(0.1, 0.99)
    ratio_wolf = np.random.uniform(0.1, (1 - 0.99))
    simulators = SimMartVaq(gt_network, ratio_honest, ratio_wolf)
    simulators.network = simulators.initialise_network(simulators.network)
    groups, groups_label = simulators.divide_in_groups(
        simulators.network, min_group=3
    )

    assert groups is not np.empty, &#34;Group list is empty&#34;
    assert all(
        [isinstance(item, int) for item in groups]
    ), &#34;Items in Group should be int&#34;
    assert isinstance(groups_label, frozenset), &#34;Group label should be frozenset&#34;
    assert len(groups_label) &gt; 0, &#34;Group label is empty&#34;
    assert all(
        [isinstance(item, int) for item in groups_label]
    ), &#34;Items in Group label should be int&#34;</code></pre>
</details>
</dd>
<dt id="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_evolutionary_stage"><code class="name flex">
<span>def <span class="ident">test_evolutionary_stage</span></span>(<span>self, gt_network: graph_tool.Graph) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Test if the evolutionary stage is working correctly.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.essential
def test_evolutionary_stage(self, gt_network: gt.Graph) -&gt; None:
    &#34;&#34;&#34;Test if the evolutionary stage is working correctly.&#34;&#34;&#34;
    simulators = SimMartVaq(
        gt_network, mutation_prob=0.3, temperature=10, ratio_honest=0.8
    )
    # Need to randomly change the fitness
    np.random.seed(0)
    network = simulators.initialise_network(simulators.network)
    network = simulators.init_fitness(simulators.network)
    np.random.seed(0)
    for i in range(0, network.num_vertices()):
        network.vp.fitness[network.vertex(i)] = np.random.randint(0, 200)

    # To compare it to the other object
    untouched_network = deepcopy(network)
    min_grp = 5
    max_grp = 10
    dict_of_communities = simulators.select_multiple_communities(
        network=network, radius=3, min_grp=min_grp, max_grp=max_grp
    )
    mbrs = dict_of_communities[min_grp]

    # Check if the players changed status
    # With seed 0, role interchange is triggered
    np.random.seed(0)
    network = simulators.evolutionary_stage(network, mbrs)

    assert (
        network.vp.state[network.vertex(74)]
        == untouched_network.vp.state[untouched_network.vertex(291)]
    ), &#34;Interchange function didn&#39;t work properly&#34;
    assert (
        network.vp.state[network.vertex(291)]
        == untouched_network.vp.state[untouched_network.vertex(291)]
    ), &#34;Interchange function didn&#39;t work properly&#34;

    # Check if the players changed status
    # With seed 5, mutation is triggered
    np.random.seed(10)
    network = simulators.evolutionary_stage(network, mbrs)
    assert (
        network.vp.state[network.vertex(515)] == &#34;c&#34;
    ), &#34;Mutation function didn&#39;t work properly&#34;</code></pre>
</details>
</dd>
<dt id="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_fermi_function"><code class="name flex">
<span>def <span class="ident">test_fermi_function</span></span>(<span>self, create_gt_network: graph_tool.Graph) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Test if the fermi function is working correclty.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.essential
def test_fermi_function(self, create_gt_network: gt.Graph) -&gt; None:
    &#34;&#34;&#34;Test if the fermi function is working correclty.&#34;&#34;&#34;
    # The given network is just a placeholder
    simulators = SimMartVaq(create_gt_network)
    np.random.seed(0)
    assert simulators.fermi_function(40, 3), &#34;Should be True&#34;
    assert simulators.fermi_function(-40.1, 3) is False, &#34;Should be False&#34;</code></pre>
</details>
</dd>
<dt id="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_fermi_function_for_overflow"><code class="name flex">
<span>def <span class="ident">test_fermi_function_for_overflow</span></span>(<span>self, create_gt_network_session: graph_tool.Graph) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Test for fermi function if overflow still occurs.</p>
<p>Hypothesis package is used to test random numbers</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.essential
@given(
    x=st.floats(allow_nan=False, allow_infinity=False),
    y=st.floats(allow_nan=False, allow_infinity=False),
    t=st.floats(allow_nan=False, allow_infinity=False),
)
def test_fermi_function_for_overflow(
    self, x: float, y: float, t: int, create_gt_network_session: gt.Graph
) -&gt; None:
    &#34;&#34;&#34;Test for fermi function if overflow still occurs.

    Hypothesis package is used to test random numbers
    &#34;&#34;&#34;
    assume(t != 0)
    simulators = SimMartVaq(create_gt_network_session, temperature=t)

    # Since it returns a bool anyway it will trigger the assert statements
    # But her the goal is to trigger an overflow in the equation
    try:
        simulators.fermi_function(x, y)
    except RuntimeError as e:
        raise Exception(f&#34;An error occurred with value {x},{y},{t}&#34;) from e</code></pre>
</details>
</dd>
<dt id="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_get_analytical_solution"><code class="name flex">
<span>def <span class="ident">test_get_analytical_solution</span></span>(<span>self, gt_network: graph_tool.Graph) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Test if get_analytical_solution works correctly.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.essential
def test_get_analytical_solution(self, gt_network: gt.Graph) -&gt; None:
    &#34;&#34;&#34;Test if get_analytical_solution works correctly.&#34;&#34;&#34;
    simulators = SimMartVaq(
        gt_network,
        ratio_honest=0.5,
        ratio_wolf=0.2,
        c_c=2,
        r_c=4,
        c_w=5,
        r_w=7,
        delta=0.5,
        tau=4,
        gamma=2,
        beta_h=20,
        beta_s=32,
        beta_c=40,
    )
    mean_fitness_dict = simulators.get_analytical_solution()

    assert mean_fitness_dict[&#34;h&#34;] != 0
    assert mean_fitness_dict[&#34;c&#34;] != 0
    assert mean_fitness_dict[&#34;w&#34;] != 0

    assert isinstance(mean_fitness_dict[&#34;h&#34;], float)
    assert isinstance(mean_fitness_dict[&#34;c&#34;], float)
    assert isinstance(mean_fitness_dict[&#34;w&#34;], float)</code></pre>
</details>
</dd>
<dt id="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_get_analytical_solution_1"><code class="name flex">
<span>def <span class="ident">test_get_analytical_solution_1</span></span>(<span>self, gt_network: graph_tool.Graph) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Test if get_analytical_solution works correctly.</p>
<p>The results should return a value of zero!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.essential
def test_get_analytical_solution_1(self, gt_network: gt.Graph) -&gt; None:
    &#34;&#34;&#34;Test if get_analytical_solution works correctly.

    The results should return a value of zero!
    &#34;&#34;&#34;
    simulators = SimMartVaq(
        gt_network,
        ratio_honest=0.5,
        ratio_wolf=0.2,
        c_c=0,
        r_c=4,
        c_w=0,
        r_w=7,
        delta=0.5,
        tau=4,
        gamma=2,
        beta_h=0,
        beta_s=0,
        beta_c=0,
    )
    mean_fitness_dict = simulators.get_analytical_solution()

    assert mean_fitness_dict[&#34;h&#34;] == 0
    assert mean_fitness_dict[&#34;c&#34;] == 0
    assert mean_fitness_dict[&#34;w&#34;] == 0

    assert isinstance(mean_fitness_dict[&#34;h&#34;], float)
    assert isinstance(mean_fitness_dict[&#34;c&#34;], float)
    assert isinstance(mean_fitness_dict[&#34;w&#34;], float)</code></pre>
</details>
</dd>
<dt id="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_get_overall_fitness_distribution"><code class="name flex">
<span>def <span class="ident">test_get_overall_fitness_distribution</span></span>(<span>self, create_gt_network: graph_tool.Graph) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Test if the get overall fitness distribution works.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.essential
def test_get_overall_fitness_distribution(
    self, create_gt_network: gt.Graph
) -&gt; None:
    &#34;&#34;&#34;Test if the get overall fitness distribution works.&#34;&#34;&#34;
    simulators = SimMartVaq(network=create_gt_network)
    mean_h, mean_c, mean_w = simulators.get_overall_fitness_distribution(
        simulators.network, list(range(0, 5))
    )

    assert mean_h == 7, &#34;Mean fitness is not correct...&#34;
    assert mean_c == 10, &#34;Mean fitness is not correct...&#34;
    assert mean_w == 7, &#34;Mean fitness is not correct...&#34;</code></pre>
</details>
</dd>
<dt id="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_hypergeometric_dist"><code class="name flex">
<span>def <span class="ident">test_hypergeometric_dist</span></span>(<span>self, create_gt_network_session: graph_tool.Graph) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Test if the hypergeometric_dict function is working.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.essential
def test_hypergeometric_dist(self, create_gt_network_session: gt.Graph) -&gt; None:
    &#34;&#34;&#34;Test if the hypergeometric_dict function is working.&#34;&#34;&#34;
    simulators = SimMartVaq(create_gt_network_session)
    assert (
        simulators.hypergeometric_dist(10, 5, 5, 15, 10, 10, 35, 20, &#34;x&#34;)
        == 0.10275099641829939
    )</code></pre>
</details>
</dd>
<dt id="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_inflicting_damage"><code class="name flex">
<span>def <span class="ident">test_inflicting_damage</span></span>(<span>self, create_gt_network: graph_tool.Graph) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Test if the inflicting damage function works correclty.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.essential
def test_inflicting_damage(self, create_gt_network: gt.Graph) -&gt; None:
    &#34;&#34;&#34;Test if the inflicting damage function works correclty.&#34;&#34;&#34;
    # set delta to 100 to make sure lone wolf acts
    simulators = SimMartVaq(
        create_gt_network, c_c=5, r_c=1, c_w=3, r_w=2, delta=100, tau=0.5
    )
    network = simulators.init_fitness(simulators.network)

    # What if the criminal is chosen
    node = 0
    network = simulators.inflict_damage(
        simulators.network,
        frozenset([0, 1, 2, 3, 4]),
        node,
        network.vp.state[network.vertex(node)],
    )
    assert network.vp.fitness[network.vertex(0)] == 30
    assert network.vp.fitness[network.vertex(2)] == 1
    assert network.vp.fitness[network.vertex(3)] == 6
    assert network.vp.fitness[network.vertex(4)] == -2

    # What if the criminal is chosen
    # Based on the previous fitness resulting from the criminal
    # activity above.
    node = 3
    network = simulators.inflict_damage(
        network,
        frozenset([0, 1, 2, 3, 4]),
        node,
        network.vp.state[network.vertex(node)],
    )
    assert network.vp.fitness[network.vertex(0)] == 36
    assert network.vp.fitness[network.vertex(2)] == -5
    assert network.vp.fitness[network.vertex(4)] == -8
    assert network.vp.fitness[network.vertex(3)] == 30</code></pre>
</details>
</dd>
<dt id="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_init_fitness"><code class="name flex">
<span>def <span class="ident">test_init_fitness</span></span>(<span>self, gt_network: graph_tool.Graph) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Test if the init of the fitness attribute is done correctly.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.essential
def test_init_fitness(self, gt_network: gt.Graph) -&gt; None:
    &#34;&#34;&#34;Test if the init of the fitness attribute is done correctly.&#34;&#34;&#34;
    simulators = SimMartVaq(gt_network)
    network = simulators.init_fitness(simulators.network)
    assert network.vp.fitness, &#34;Fitness attribute doesn&#39;t exists...&#34;</code></pre>
</details>
</dd>
<dt id="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_initialise_network"><code class="name flex">
<span>def <span class="ident">test_initialise_network</span></span>(<span>self, gt_network: graph_tool.Graph) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Test if the init process is done corretly.</p>
<p>More precisely tests if the ratio of c/h/w is correct</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.essential
def test_initialise_network(self, gt_network: gt.Graph) -&gt; None:
    &#34;&#34;&#34;Test if the init process is done corretly.

    More precisely tests if the ratio of c/h/w is correct
    &#34;&#34;&#34;
    simulators = SimMartVaq(gt_network, ratio_honest=0.2, ratio_wolf=0.3)
    network = simulators.initialise_network(simulators.network)

    # Criminal network size should be 95
    # Honest and Wolf ratio should be within a range given the init is stochastic
    assert (
        len(gt.find_vertex(network, network.vp.state, &#34;c&#34;)) == 95
    ), &#34;Criminal ratio not correct&#34;
    assert (
        38 - 15 &lt;= len(gt.find_vertex(network, network.vp.state, &#34;h&#34;)) &lt;= 38 + 15
    ), &#34;Honest ratio not correct&#34;
    assert (
        57 - 15 &lt;= len(gt.find_vertex(network, network.vp.state, &#34;w&#34;)) &lt;= 57 + 15
    ), &#34;Wolf ratio not correct&#34;</code></pre>
</details>
</dd>
<dt id="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_interchange_roles"><code class="name flex">
<span>def <span class="ident">test_interchange_roles</span></span>(<span>self, create_gt_network: graph_tool.Graph) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Test if the interchanging role is working.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.essential
def test_interchange_roles(self, create_gt_network: gt.Graph) -&gt; None:
    &#34;&#34;&#34;Test if the interchanging role is working.&#34;&#34;&#34;
    simulators = SimMartVaq(create_gt_network, temperature=10)
    # Seed 2 will trigger that the roles are interchanged
    np.random.seed(2)
    network = simulators.interchange_roles(
        network=simulators.network, person_a=0, person_b=4
    )
    # Check if wolf turned criminal based on the criminal&#39;s fitness
    assert (
        network.vp.state[network.vertex(4)] == &#34;c&#34;
    ), &#34;Wolf didn&#39;t copied criminal....&#34;
    assert (
        network.vp.state[network.vertex(0)] == &#34;w&#34;
    ), &#34;Criminal didn&#39;t copied wolf....&#34;</code></pre>
</details>
</dd>
<dt id="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_investigation_stage"><code class="name flex">
<span>def <span class="ident">test_investigation_stage</span></span>(<span>self, create_gt_network: graph_tool.Graph) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Test if the investigation stage is working correctly.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.essential
def test_investigation_stage(self, create_gt_network: gt.Graph) -&gt; None:
    &#34;&#34;&#34;Test if the investigation stage is working correctly.&#34;&#34;&#34;
    # Define the different penalties
    simulators = SimMartVaq(
        create_gt_network, gamma=0.5, beta_c=2, beta_s=3, beta_h=5
    )
    network = simulators.init_fitness(simulators.network)

    # What if the criminal is chosen
    # Triggers state and civilian punishment
    np.random.seed(2)
    node = 0
    network = simulators.investigation_stage(
        simulators.network,
        frozenset([0, 1, 2, 3, 4]),
        node,
        network.vp.state[network.vertex(node)],
    )
    assert network.vp.fitness[network.vertex(0)] == 5
    assert network.vp.fitness[network.vertex(1)] == 8
    assert network.vp.fitness[network.vertex(2)] == 6
    assert network.vp.fitness[network.vertex(3)] == 11
    assert network.vp.fitness[network.vertex(4)] == 3

    # What if the lone wolf is not chosen
    # Based on the previous fitness resulting from the criminal
    # activity above.
    np.random.seed(3)
    node = 3
    # Wolf did act
    simulators.wolf_acting = True
    network = simulators.investigation_stage(
        network,
        frozenset([0, 1, 2, 3, 4]),
        node,
        network.vp.state[network.vertex(node)],
    )
    assert network.vp.fitness[network.vertex(0)] == 5
    assert network.vp.fitness[network.vertex(1)] == 8
    assert network.vp.fitness[network.vertex(2)] == 6
    assert network.vp.fitness[network.vertex(3)] == 11
    assert network.vp.fitness[network.vertex(4)] == 3

    # What if the lone wolf is chosen
    # Based on the previous fitness resulting from the criminal
    # activity above.
    np.random.seed(6)
    node = 3
    # Wolf did act
    simulators.wolf_acting = True
    network = simulators.investigation_stage(
        network,
        frozenset([0, 1, 2, 3, 4]),
        node,
        network.vp.state[network.vertex(node)],
    )
    assert network.vp.fitness[network.vertex(0)] == 5
    assert network.vp.fitness[network.vertex(1)] == 8
    assert network.vp.fitness[network.vertex(2)] == 6
    assert network.vp.fitness[network.vertex(3)] == 10.6
    assert network.vp.fitness[network.vertex(4)] == 3

    # Check in case multiple criminals are present
    network.vp.state[network.vertex(4)] = &#34;c&#34;
    # Triggers state and civilian punishment
    np.random.seed(2)
    node = 0
    network = simulators.investigation_stage(
        simulators.network,
        frozenset([0, 1, 2, 3, 4]),
        node,
        network.vp.state[network.vertex(node)],
    )
    assert network.vp.fitness[network.vertex(0)] == 0
    assert network.vp.fitness[network.vertex(1)] == 8
    assert network.vp.fitness[network.vertex(2)] == 6
    assert network.vp.fitness[network.vertex(3)] == 10.6
    assert network.vp.fitness[network.vertex(4)] == 0.5</code></pre>
</details>
</dd>
<dt id="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_mean_field_approx"><code class="name flex">
<span>def <span class="ident">test_mean_field_approx</span></span>(<span>self, create_gt_network_session: graph_tool.Graph) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Test if the mean_field_approx func works correctly using arbitrary arg.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.essential
def test_mean_field_approx(self, create_gt_network_session: gt.Graph) -&gt; None:
    &#34;&#34;&#34;Test if the mean_field_approx func works correctly using arbitrary arg.&#34;&#34;&#34;
    simulators = SimMartVaq(
        create_gt_network_session,
        c_c=2,
        r_c=4,
        c_w=5,
        r_w=7,
        delta=0.5,
        tau=4,
        gamma=2,
        beta_h=20,
        beta_s=32,
        beta_c=40,
    )

    mean_filed_approx = simulators.mean_field_approx(p_h=0.5, p_c=0.3, N=40, N_w=9)

    assert (
        pytest.approx(mean_filed_approx[&#34;h&#34;][&#34;a&#34;]) == -1.33125
    ), &#34;Value is not correct&#34;
    assert (
        pytest.approx(mean_filed_approx[&#34;c&#34;][&#34;a&#34;]) == 93.59375
    ), &#34;Value is not correct&#34;
    assert (
        pytest.approx(mean_filed_approx[&#34;w&#34;][&#34;a&#34;]) == -67.79375
    ), &#34;Value is not correct&#34;
    assert pytest.approx(mean_filed_approx[&#34;h&#34;][&#34;i&#34;]) == 0, &#34;Value is not correct&#34;
    assert (
        pytest.approx(mean_filed_approx[&#34;c&#34;][&#34;i&#34;]) == -7.245
    ), &#34;Value is not correct&#34;
    assert (
        pytest.approx(mean_filed_approx[&#34;w&#34;][&#34;i&#34;]) == -0.0219375
    ), &#34;Value is not correct&#34;</code></pre>
</details>
</dd>
<dt id="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_mean_field_approx_1"><code class="name flex">
<span>def <span class="ident">test_mean_field_approx_1</span></span>(<span>self, create_gt_network_session: graph_tool.Graph) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Test if the mean_field_approx func works correctly using arbitrary arg.</p>
<p>The return value should be zero</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.essential
def test_mean_field_approx_1(self, create_gt_network_session: gt.Graph) -&gt; None:
    &#34;&#34;&#34;Test if the mean_field_approx func works correctly using arbitrary arg.

    The return value should be zero
    &#34;&#34;&#34;
    simulators = SimMartVaq(
        create_gt_network_session,
        c_c=0,
        r_c=4,
        c_w=0,
        r_w=7,
        delta=0.5,
        tau=4,
        gamma=2,
        beta_h=0,
        beta_s=0,
        beta_c=0,
    )
    mean_filed_approx = simulators.mean_field_approx(p_h=0.5, p_c=0.3, N=40, N_w=9)
    assert pytest.approx(mean_filed_approx[&#34;h&#34;][&#34;a&#34;]) == 0, &#34;Value is not correct&#34;
    assert pytest.approx(mean_filed_approx[&#34;c&#34;][&#34;a&#34;]) == 0, &#34;Value is not correct&#34;
    assert pytest.approx(mean_filed_approx[&#34;w&#34;][&#34;a&#34;]) == 0, &#34;Value is not correct&#34;
    assert pytest.approx(mean_filed_approx[&#34;h&#34;][&#34;i&#34;]) == 0, &#34;Value is not correct&#34;
    assert pytest.approx(mean_filed_approx[&#34;c&#34;][&#34;i&#34;]) == 0, &#34;Value is not correct&#34;
    assert pytest.approx(mean_filed_approx[&#34;w&#34;][&#34;i&#34;]) == 0, &#34;Value is not correct&#34;</code></pre>
</details>
</dd>
<dt id="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_mutation"><code class="name flex">
<span>def <span class="ident">test_mutation</span></span>(<span>self, create_gt_network: graph_tool.Graph) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Test if the mutation works correclty.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.essential
def test_mutation(self, create_gt_network: gt.Graph) -&gt; None:
    &#34;&#34;&#34;Test if the mutation works correclty.&#34;&#34;&#34;
    simulators = SimMartVaq(create_gt_network, temperature=10)
    # The seed should turn nodes into a criminal,honest or wolf
    np.random.seed(0)
    node = 4
    network = simulators.mutation(simulators.network, person=node)
    assert (
        network.vp.state[network.vertex(node)] == &#34;c&#34;
    ), &#34;Mutation didn&#39;t work properly&#34;
    node = 0
    network = simulators.mutation(simulators.network, person=node)
    assert (
        network.vp.state[network.vertex(node)] == &#34;h&#34;
    ), &#34;Mutation didn&#39;t work properly&#34;
    node = 3
    network = simulators.mutation(simulators.network, person=node)
    assert (
        network.vp.state[network.vertex(node)] == &#34;c&#34;
    ), &#34;Mutation didn&#39;t work properly&#34;</code></pre>
</details>
</dd>
<dt id="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_play"><code class="name flex">
<span>def <span class="ident">test_play</span></span>(<span>self, gt_network: graph_tool.Graph) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Test if the play function is working.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.essential
def test_play(self, gt_network: gt.Graph) -&gt; None:
    &#34;&#34;&#34;Test if the play function is working.&#34;&#34;&#34;
    # Play the simulation
    rounds = 50
    simulator = SimMartVaq(gt_network, ratio_honest=0.7, ratio_wolf=0.05)
    network, data_collector = simulator.play(simulator.network, rounds=rounds)

    # Check if the data_collectors collect at each round data
    assert (
        len(data_collector[&#34;ratio_honest&#34;]) == rounds
    ), &#34;Length of the collected data is not correct...&#34;
    assert (
        len(data_collector[&#34;ratio_wolf&#34;]) == rounds
    ), &#34;Length of the collected data is not correct...&#34;
    assert (
        len(data_collector[&#34;ratio_criminal&#34;]) == rounds
    ), &#34;Length of the collected data is not correct...&#34;
    assert (
        len(data_collector[&#34;fitness_honest&#34;]) == rounds
    ), &#34;Length of the collected data is not correct...&#34;
    assert (
        len(data_collector[&#34;fitness_criminal&#34;]) == rounds
    ), &#34;Length of the collected data is not correct...&#34;
    assert (
        len(data_collector[&#34;fitness_wolf&#34;]) == rounds
    ), &#34;Length of the collected data is not correct...&#34;

    # Check if the data does indeed changes, checks the simulation is working
    assert (
        len(set(data_collector[&#34;ratio_honest&#34;])) &gt; 1
    ), &#34;Collectors keep collecting same value...&#34;
    assert (
        len(set(data_collector[&#34;ratio_wolf&#34;])) &gt; 1
    ), &#34;Collectors keep collecting same value...&#34;
    assert (
        len(set(data_collector[&#34;ratio_criminal&#34;])) &gt; 1
    ), &#34;Collectors keep collecting same value...&#34;
    assert (
        len(set(data_collector[&#34;fitness_honest&#34;])) &gt; 1
    ), &#34;Collectors keep collecting same value...&#34;
    assert (
        len(set(data_collector[&#34;fitness_criminal&#34;])) &gt; 1
    ), &#34;Collectors keep collecting same value...&#34;
    assert (
        len(set(data_collector[&#34;fitness_wolf&#34;])) &gt; 1
    ), &#34;Collectors keep collecting same value...&#34;</code></pre>
</details>
</dd>
<dt id="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_scenario_1"><code class="name flex">
<span>def <span class="ident">test_scenario_1</span></span>(<span>self, gt_network: graph_tool.Graph) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Test specific scenario.</p>
<p>Test the scenario where no mutation happens and criminals
have no benefits by acting but they act. Also wolfs do not act.
Also no punish is conduced.
So no change in the fitness is expected.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.essential
def test_scenario_1(self, gt_network: gt.Graph) -&gt; None:
    &#34;&#34;&#34;Test specific scenario.

    Test the scenario where no mutation happens and criminals
    have no benefits by acting but they act. Also wolfs do not act.
    Also no punish is conduced.
    So no change in the fitness is expected.
    &#34;&#34;&#34;
    simulators = SimMartVaq(
        network=gt_network,
        ratio_honest=0.45,
        ratio_wolf=0.45,
        delta=-10,  # no acting for wolfs
        gamma=0.5,
        tau=0,  # no fintess sharing between wolf to criminal
        beta_s=0,
        beta_h=0,
        beta_c=0,
        c_c=0,  # no benefits from criminals/ they still act
        r_c=10,
        c_w=10,
        r_w=10,
        mutation_prob=-0.1,  # only fermi function
    )
    _, data_collector = simulators.play(
        network=simulators.network, rounds=100, radius=3
    )

    # not any returns True if all element are False/0
    assert not any(
        data_collector[&#34;fitness_honest&#34;]
    ), &#34;Fitness should be zero all the time&#34;
    assert not any(
        data_collector[&#34;fitness_wolf&#34;]
    ), &#34;Fitness should be zero all the time&#34;
    assert not any(
        data_collector[&#34;fitness_criminal&#34;]
    ), &#34;Fitness should be zero all the time&#34;</code></pre>
</details>
</dd>
<dt id="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_select_communities"><code class="name flex">
<span>def <span class="ident">test_select_communities</span></span>(<span>self, gt_network: graph_tool.Graph) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Test if the random select communites is working correctly.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.essential
def test_select_communities(self, gt_network: gt.Graph) -&gt; None:
    &#34;&#34;&#34;Test if the random select communites is working correctly.&#34;&#34;&#34;
    simulators = SimMartVaq(gt_network)
    network = simulators.init_fitness(simulators.network)

    # Depth 1
    seed = np.random.randint(0, gt_network.num_vertices())
    community = simulators.select_communities(network, radius=1, seed=seed)
    nbrs = network.iter_all_neighbors(seed)
    assert list(nbrs) != community

    # Depth 2
    seed = np.random.randint(0, gt_network.num_vertices())
    community = simulators.select_communities(network, radius=2, seed=seed)
    nbrs = list(network.iter_all_neighbors(seed))
    scnd_degree_nbr: list = []
    for nbr in nbrs:
        scnd_degree_nbr = scnd_degree_nbr + list(network.get_all_neighbors(nbr))

    nbrs = nbrs + scnd_degree_nbr
    assert set(nbrs) == community

    # Depth 3
    seed = np.random.randint(0, gt_network.num_vertices())
    community = simulators.select_communities(network, radius=3, seed=seed)
    nbrs = list(network.iter_all_neighbors(seed))
    scnd_degree_nbr = []
    for nbr in nbrs:
        scnd_degree_nbr = scnd_degree_nbr + list(network.get_all_neighbors(nbr))

    third_degree_nbr: list = []
    for nbr in scnd_degree_nbr:
        third_degree_nbr = third_degree_nbr + list(network.get_all_neighbors(nbr))

    nbrs = nbrs + scnd_degree_nbr + third_degree_nbr
    assert set(nbrs) == community</code></pre>
</details>
</dd>
<dt id="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_select_multiple_communities"><code class="name flex">
<span>def <span class="ident">test_select_multiple_communities</span></span>(<span>self, gt_network: graph_tool.Graph) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Test if select_multiple_communities works correctly.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.essential
def test_select_multiple_communities(self, gt_network: gt.Graph) -&gt; None:
    &#34;&#34;&#34;Test if select_multiple_communities works correctly.&#34;&#34;&#34;
    simulators = SimMartVaq(gt_network)
    network = simulators.init_fitness(simulators.network)
    min_grp = 5
    max_grp = 10
    dict_of_communities = simulators.select_multiple_communities(
        network=network, radius=1, min_grp=min_grp, max_grp=max_grp
    )

    assert len(dict_of_communities) != 0, &#34;Dict of communities is empty...&#34;
    assert (
        min_grp &lt;= len(dict_of_communities) &lt;= max_grp
    ), &#34;Number of communites is not correct...&#34;

    for k, v in dict_of_communities.items():
        assert isinstance(k, int)
        assert len(dict_of_communities[k]) &gt;= 1, &#34;Some communities are empty...&#34;</code></pre>
</details>
</dd>
<dt id="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_sim_mart_vaq"><code class="name flex">
<span>def <span class="ident">test_sim_mart_vaq</span></span>(<span>self, gt_network: graph_tool.Graph) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Test if the initialization works.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.essential
def test_sim_mart_vaq(self, gt_network: gt.Graph) -&gt; None:
    &#34;&#34;&#34;Test if the initialization works.&#34;&#34;&#34;
    org_size = gt_network.num_vertices()
    # Keep the ratio small so the test will be faster
    # by adding less nodes
    ratio_honest = 0.3
    ratio_wolf = 0.1

    simulators = SimMartVaq(gt_network, ratio_honest, ratio_wolf)

    # Test if the obj is init correctly
    assert isinstance(
        simulators, SimMartVaq
    ), &#34;Simulator hasn&#39;t been init correctly&#34;

    # Test if the ratio is caluclated correctly
    assert simulators.ratio_criminal == 0.6, &#34;Ratio is wrong.&#34;
    assert (
        simulators.n_criminal == org_size
    ), &#34;Determined number of criminals is wrong.&#34;
    assert simulators.total_number_nodes == 158, &#34;Ratio is wrong&#34;
    assert simulators.new_nodes == 63, &#34;Number of nodes to add is wrong&#34;
    assert (
        round(simulators.relative_ratio_honest, 2) == 0.75
    ), &#34;Relative ratio is wrong&#34;
    assert (
        round(simulators.relative_ratio_wolf, 2) == 0.25
    ), &#34;Relative ratio is wrong&#34;

    # Try to change its name
    with pytest.raises(Exception):
        simulators.name = &#34;New name&#34;</code></pre>
</details>
</dd>
<dt id="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_sim_mart_vaq_wrong_init"><code class="name flex">
<span>def <span class="ident">test_sim_mart_vaq_wrong_init</span></span>(<span>self, gt_network: graph_tool.Graph) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Test if a wrong init triggers the assert statements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.essential
def test_sim_mart_vaq_wrong_init(self, gt_network: gt.Graph) -&gt; None:
    &#34;&#34;&#34;Test if a wrong init triggers the assert statements.&#34;&#34;&#34;
    # With ratio_honest == 0
    with pytest.raises(Exception):
        assert SimMartVaq(gt_network, ratio_honest=0)

    # With ratio_wolf == 1.1
    with pytest.raises(Exception):
        assert SimMartVaq(gt_network, ratio_wolf=1.1)

    # With ratios not adding up more than 1
    with pytest.raises(Exception):
        assert SimMartVaq(gt_network, ratio_honest=0.8, ratio_wolf=0.3)
        assert SimMartVaq(gt_network, ratio_honest=0.8, ratio_wolf=0.2)
        assert SimMartVaq(gt_network, ratio_honest=-0.8, ratio_wolf=0.1)
        assert SimMartVaq(gt_network, ratio_honest=-0.8, ratio_wolf=0.2)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="test.tests_simulators" href="index.html">test.tests_simulators</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq" href="#test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq">TestSimMartVaq</a></code></h4>
<ul class="">
<li><code><a title="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_act_divide_in_groups" href="#test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_act_divide_in_groups">test_act_divide_in_groups</a></code></li>
<li><code><a title="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_act_divide_in_groups_faster" href="#test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_act_divide_in_groups_faster">test_act_divide_in_groups_faster</a></code></li>
<li><code><a title="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_acting_stage" href="#test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_acting_stage">test_acting_stage</a></code></li>
<li><code><a title="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_acting_stage_2" href="#test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_acting_stage_2">test_acting_stage_2</a></code></li>
<li><code><a title="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_avg_play" href="#test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_avg_play">test_avg_play</a></code></li>
<li><code><a title="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_counting_status_proportions" href="#test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_counting_status_proportions">test_counting_status_proportions</a></code></li>
<li><code><a title="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_divide_in_groups" href="#test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_divide_in_groups">test_divide_in_groups</a></code></li>
<li><code><a title="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_evolutionary_stage" href="#test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_evolutionary_stage">test_evolutionary_stage</a></code></li>
<li><code><a title="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_fermi_function" href="#test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_fermi_function">test_fermi_function</a></code></li>
<li><code><a title="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_fermi_function_for_overflow" href="#test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_fermi_function_for_overflow">test_fermi_function_for_overflow</a></code></li>
<li><code><a title="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_get_analytical_solution" href="#test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_get_analytical_solution">test_get_analytical_solution</a></code></li>
<li><code><a title="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_get_analytical_solution_1" href="#test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_get_analytical_solution_1">test_get_analytical_solution_1</a></code></li>
<li><code><a title="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_get_overall_fitness_distribution" href="#test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_get_overall_fitness_distribution">test_get_overall_fitness_distribution</a></code></li>
<li><code><a title="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_hypergeometric_dist" href="#test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_hypergeometric_dist">test_hypergeometric_dist</a></code></li>
<li><code><a title="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_inflicting_damage" href="#test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_inflicting_damage">test_inflicting_damage</a></code></li>
<li><code><a title="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_init_fitness" href="#test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_init_fitness">test_init_fitness</a></code></li>
<li><code><a title="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_initialise_network" href="#test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_initialise_network">test_initialise_network</a></code></li>
<li><code><a title="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_interchange_roles" href="#test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_interchange_roles">test_interchange_roles</a></code></li>
<li><code><a title="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_investigation_stage" href="#test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_investigation_stage">test_investigation_stage</a></code></li>
<li><code><a title="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_mean_field_approx" href="#test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_mean_field_approx">test_mean_field_approx</a></code></li>
<li><code><a title="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_mean_field_approx_1" href="#test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_mean_field_approx_1">test_mean_field_approx_1</a></code></li>
<li><code><a title="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_mutation" href="#test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_mutation">test_mutation</a></code></li>
<li><code><a title="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_play" href="#test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_play">test_play</a></code></li>
<li><code><a title="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_scenario_1" href="#test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_scenario_1">test_scenario_1</a></code></li>
<li><code><a title="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_select_communities" href="#test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_select_communities">test_select_communities</a></code></li>
<li><code><a title="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_select_multiple_communities" href="#test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_select_multiple_communities">test_select_multiple_communities</a></code></li>
<li><code><a title="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_sim_mart_vaq" href="#test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_sim_mart_vaq">test_sim_mart_vaq</a></code></li>
<li><code><a title="test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_sim_mart_vaq_wrong_init" href="#test.tests_simulators.test_sim_mart_vaq.TestSimMartVaq.test_sim_mart_vaq_wrong_init">test_sim_mart_vaq_wrong_init</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
