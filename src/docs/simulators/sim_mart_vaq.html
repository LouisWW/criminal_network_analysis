<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>simulators.sim_mart_vaq API documentation</title>
<meta name="description" content="This script&#39;s intention is to simulate the evolution of a criminal network …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>simulators.sim_mart_vaq</code></h1>
</header>
<section id="section-intro">
<p>This script's intention is to simulate the evolution of a criminal network.</p>
<p>Martinez-Vaquero, L. A., Dolci, V., &amp; Trianni, V. (2019).
Evolutionary dynamics of organised crime and terrorist networks. Scientific reports, 9(1), 1-10.</p>
<p><strong>author</strong> = Louis Weyland
<strong>date</strong>
= 11/04/2022</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;This script&#39;s intention is to simulate the evolution of a criminal network.

Martinez-Vaquero, L. A., Dolci, V., &amp; Trianni, V. (2019).
Evolutionary dynamics of organised crime and terrorist networks. Scientific reports, 9(1), 1-10.

__author__ = Louis Weyland
__date__   = 11/04/2022
&#34;&#34;&#34;
import gc
import logging
import multiprocessing
import random
import warnings
from collections import defaultdict
from typing import Any
from typing import DefaultDict
from typing import Dict
from typing import List
from typing import Tuple
from typing import Union

import graph_tool.all as gt
import numpy as np
import pandas as pd
from network_utils.network_extractor import NetworkExtractor
from network_utils.node_stats import NodeStats
from p_tqdm import p_umap
from tqdm import tqdm
from utils.mt_random_c import random_c
from utils.stats import concat_df
from utils.stats import get_mean_std_over_list

# suppress warnings
warnings.filterwarnings(&#34;ignore&#34;)
logger = logging.getLogger(&#34;logger&#34;)


class SimMartVaq:
    &#34;&#34;&#34;Contain the framework to simulate the evolutionary dynamic of a criminal network.&#34;&#34;&#34;

    def __init__(
        self,
        network: gt.Graph,
        delta: float = 0.1,
        tau: float = 0.1,
        gamma: float = 0.1,
        beta_s: int = 1,
        beta_h: int = 1,
        beta_c: int = 1,
        c_w: int = 1,
        c_c: int = 1,
        r_w: int = 1,
        r_c: int = 1,
        r_h: int = 0,
        temperature: float = 10,
        mutation_prob: float = 0.0001,
        execute: str = &#34;parallel&#34;,
    ) -&gt; None:
        &#34;&#34;&#34;Init the network characteristics.

        Args:
            network (gt.Graph): Initial criminal network
            delta (int, optional): Influence of criminals on the acting of the wolf.
                                   Defaults to 0.1.
            tau (int, optional):Influence of the wolf&#39;s action on criminals. Defaults to 0.1.
            gamma (float, optional): Punishment ratio for the other members of the criminal
                                                                    organization. Defaults to 0.1.
            beta_s (int, optional): state punishment value. Defaults to 1.
            beta_h (int, optional): Civil punishment value. Defaults to 1.
            beta_c (int, optional): Criminal punishment value. Defaults to 1.
            c_w (int, optional): Damage caused by wolf. Defaults to 1.
            c_c (int, optional): Damage caused by criminal. Defaults to 1.
            r_w (int, optional): Reward ratio for wolf. Defaults to 1.
            r_c (int, optional): Reward ratio for criminal. Defaults to 1.
            r_h (int, optional): Bonus ratio for honest. Defaults to 0.
            temperature (int, optional): Temperature used in the fermi function. Defaults to 10.
            mutation_prob (float, optional): Mutation probability to either randomly pick a
                                new status or switch status with an other agent. Defaults to 0.0001.
            execute (str,optional): Defines if some process should run parallel or sequential.
                                    Default to parallel.
        &#34;&#34;&#34;
        # Define name of simulator
        self._name = &#34;sim_mart_vaq&#34;
        self.network = network
        self.network.status = np.asarray(list(network.vp.status))
        self.network.fitness = np.zeros(network.num_vertices())
        self.network.age = np.zeros(network.num_vertices())

        # Check if data is coherent
        assert isinstance(network, gt.Graph), &#34;Network should be of type gt.&#34;
        assert network.vp.status, &#34;Network has no attribute status&#34;
        self.ratio_honest = (
            len(gt.find_vertex(network, network.vp.status, &#34;h&#34;))
            / self.network.num_vertices()
        )
        self.ratio_wolf = (
            len(gt.find_vertex(network, network.vp.status, &#34;w&#34;))
            / self.network.num_vertices()
        )
        self.ratio_criminal = (
            len(gt.find_vertex(network, network.vp.status, &#34;c&#34;))
            / self.network.num_vertices()
        )

        assert np.isclose(self.ratio_honest + self.ratio_wolf + self.ratio_criminal, 1)

        # Set damaging and punishing parameters
        self.delta = delta
        self.tau = tau
        self.gamma = gamma
        self.beta_s = beta_s
        self.beta_h = beta_h
        self.beta_c = beta_c
        self.c_w = c_w
        self.c_c = c_c
        self.r_w = r_w
        self.r_c = r_c
        self.r_h = r_h

        # Set the fermic temperature &amp; mutation probability
        self.temperature = temperature
        self.mutation_prob = mutation_prob

        # Set the execute, if parallel or sequential
        self.execute = execute

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;Return the name of the simulator.&#34;&#34;&#34;
        return self._name

    def play(
        self,
        network: gt.Graph,
        rounds: int = 1,
        n_groups: int = 1,
        ith_collect: int = 20,
        collect_fitness: bool = True,
        measure_topology: bool = False,
        measure_likelihood_corr: bool = False,
        show_no_bar: bool = True,
        rnd_fit_init: bool = False,
    ) -&gt; Tuple[gt.Graph, DefaultDict[str, List[Any]]]:
        &#34;&#34;&#34;Play the agent-based model.

        Args:
            network (gt.Graph): population including honests,lone actors and criminals.
            rounds (int, optional): number of rounds to play. Defaults to 1.
            n_groups (int, optional): each round select how many people are selected from the pool.
                                    Defaults to 1.
            ith_collect (int, optional): collect ratio every nth round (for speed improvement).
                                        Defaults to 20.
            collect_fitness (bool, optional): collect fitness. Defaults to True.
            measure_topology (bool, optional): collect secrecy,flow of information and giant comp.
                                        Defaults to False.
            measure_likelihood_corr (bool, optional): collect the likelihood of a node to be
                                                        criminal. Defaults to False.
            show_no_bar (bool, optional): show progress bar or not. Defaults to True.
            rnd_fit_init (bool, optional): assign random fitness to nodes. Defaults to False.

        Returns:
            Tuple[gt.Graph, DefaultDict[str, List[Any]]]: returns population and dictionary
                                                                containing all the measurements.
        &#34;&#34;&#34;
        network.status = np.asarray(list(network.vp.status))
        if rnd_fit_init:
            network.fitness = np.random.uniform(50, -50, network.num_vertices())
        else:
            network.fitness = np.zeros(network.num_vertices())
        network.age = np.zeros(network.num_vertices())

        # collectors which collects the ratio and fitness over each iteration
        data_collector = defaultdict(
            list,
            {
                k: []
                for k in (
                    &#34;ratio_honest&#34;,
                    &#34;ratio_criminal&#34;,
                    &#34;ratio_wolf&#34;,
                    &#34;fitness_honest&#34;,
                    &#34;fitness_criminal&#34;,
                    &#34;fitness_wolf&#34;,
                    &#34;secrecy&#34;,
                    &#34;flow_information&#34;,
                    &#34;size_of_largest_component&#34;,
                    &#34;df&#34;,
                )
            },
        )  # type: DefaultDict[str, List[Any]]

        # Run the simulation
        for i in tqdm(
            range(1, rounds + 1),
            desc=&#34;Playing the rounds...&#34;,
            total=rounds,
            leave=False,
            disable=False,
        ):
            # Divide the network in random new groups
            dict_of_group = self.slct_pers_n_neighbours(
                network=network, n_groups=n_groups, network_size=network.num_vertices()
            )

            # Go through each group
            for slct_pers, group_members in dict_of_group.items():

                # Check the person status
                slct_pers_status = network.status[slct_pers]

                # Acting stage
                network, slct_pers, slct_status = self.acting_stage(
                    network, slct_pers, slct_pers_status, group_members
                )
                # Investigation stage
                network = self.investigation_stage(
                    network, group_members, slct_pers, slct_status
                )

            # Divide the network in random new groups for evolutionary process
            dict_of_group_evol = self.slct_pers_n_neighbours(
                network=network,
                n_groups=n_groups,
                network_size=network.num_vertices(),
            )
            # Go through each group
            for slct_pers_evol, group_members_evol in dict_of_group_evol.items():
                # Evolutionary stage
                network = self.evolutionary_stage(
                    network, slct_pers_evol, group_members_evol
                )

            if measure_likelihood_corr:
                network = self.update_age(network)

            # update fitness decay
            network = self.update_fitness(network)

            # Collect the data
            if i % ith_collect == 0 or i == 1:
                _, _, _, p_c, p_h, p_w = self.counting_status_proportions(
                    network=network,
                    group_members=list(range(0, network.num_vertices())),
                )

                data_collector[&#34;iteration&#34;].append(i)
                data_collector[&#34;ratio_honest&#34;].append(p_h)
                data_collector[&#34;ratio_wolf&#34;].append(p_w)
                data_collector[&#34;ratio_criminal&#34;].append(p_c)

                if collect_fitness:
                    (
                        mean_h_fit,
                        mean_c_fit,
                        mean_w_fit,
                    ) = self.get_overall_fitness_distribution(network=network)
                    data_collector[&#34;fitness_honest&#34;].append(mean_h_fit)
                    data_collector[&#34;fitness_criminal&#34;].append(mean_c_fit)
                    data_collector[&#34;fitness_wolf&#34;].append(mean_w_fit)

                if measure_topology:
                    # Extract the criminal network, the filtering is done on the network object
                    logger.info(&#34;Filtering the criminal_network&#34;)
                    NetworkExtractor.filter_criminal_network(network)

                    if network.num_vertices() == 0:
                        logger.info(&#34;No criminals in the network&#34;)
                        logger.info(&#34;Calculating the secrecy&#34;)
                        data_collector[&#34;secrecy&#34;].append(-1)
                        data_collector[&#34;density&#34;].append(0)
                        logger.info(&#34;Calculating the flow of information&#34;)
                        data_collector[&#34;flow_information&#34;].append(0)
                        logger.info(&#34;Calculating the largest_component&#34;)
                        data_collector[&#34;size_of_largest_component&#34;].append(0)

                    elif network.num_vertices() &gt;= 1:
                        logger.info(&#34;Calculating the secrecy&#34;)
                        data_collector[&#34;secrecy&#34;].append(NodeStats.get_secrecy(network))
                        data_collector[&#34;density&#34;].append(NodeStats.get_density(network))
                        logger.info(&#34;Calculating the flow of information&#34;)

                        gsc = gt.extract_largest_component(network)
                        if self.execute == &#34;parallel&#34;:
                            data_collector[&#34;flow_information&#34;].append(
                                NodeStats.get_flow_of_information(gsc)
                            )
                        elif self.execute == &#34;sequential&#34;:
                            # the faster version doesn&#39;t work sequentially
                            data_collector[&#34;flow_information&#34;].append(
                                NodeStats.get_flow_of_information_faster(gsc)
                            )

                        logger.info(&#34;Calculating the largest_component&#34;)
                        data_collector[&#34;size_of_largest_component&#34;].append(
                            NodeStats.get_size_of_largest_component(network)[0]
                        )

                    # Unfilter the network back to its initial configuration
                    logger.info(&#34;UnFiltering the criminal_network&#34;)
                    NetworkExtractor.un_filter_criminal_network(network)

        # Add a df with the likelihood of being a criminal and the node centrality
        if measure_likelihood_corr:
            data_collector[&#34;df&#34;] = self.create_likelihood_corr_df(network)

        gc.collect()
        return network, data_collector

    def avg_play(
        self,
        network: Union[gt.Graph, List[gt.Graph]],
        rounds: int = 1,
        n_groups: int = 20,
        ith_collect: int = 20,
        repetition: int = 20,
        measure_topology: bool = False,
        measure_likelihood_corr: bool = False,
        collect_fitness: bool = False,
        show_no_bar: bool = False,
        rnd_fit_init: bool = False,
    ) -&gt; DefaultDict[str, Union[DefaultDict[Any, Any], List[Any]]]:
        &#34;&#34;&#34;Get the average results of the simulation given the parameters.

        Args:
            network (gt.Graph, List): population or list of population
            rounds (int, optional): Rounds to play in the simulation. Defaults to 1.
            n_groups (int,optional): Number of groups to form each round
            repetition (int, optional): number of repetition of the simulation. Defaults to 20.

        Returns:
            DefaultDict[Union[int, str], Union[DefaultDict,List[Any]]]:
                                                            Returns network and collected data.
        &#34;&#34;&#34;
        # Running multiprocessing
        # If repetition are less than number of cores
        # then don&#39;t use all the cores
        if self.execute == &#34;parallel&#34;:
            if repetition &lt; multiprocessing.cpu_count() - 1:
                num_cpus = repetition
            else:
                num_cpus = multiprocessing.cpu_count() - 3

            if isinstance(network, gt.Graph):
                results = p_umap(
                    self.avg_play_help,
                    (
                        [
                            # arguments need to be in this order
                            (
                                network,
                                rounds,
                                n_groups,
                                ith_collect,
                                collect_fitness,
                                measure_topology,
                                measure_likelihood_corr,
                                show_no_bar,
                                rnd_fit_init,
                            )
                            for i in range(0, repetition)
                        ]
                    ),
                    **{&#34;num_cpus&#34;: num_cpus, &#34;desc&#34;: &#34;Repeating simulation....&#34;},
                )
            elif isinstance(network, list):
                results = p_umap(
                    self.avg_play_help,
                    (
                        [
                            # arguments need to be in this order
                            (
                                network[i],
                                rounds,
                                n_groups,
                                ith_collect,
                                collect_fitness,
                                measure_topology,
                                measure_likelihood_corr,
                                show_no_bar,
                                rnd_fit_init,
                            )
                            for i in range(0, repetition)
                        ]
                    ),
                    **{&#34;num_cpus&#34;: num_cpus, &#34;desc&#34;: &#34;Repeating simulation....&#34;},
                )

            # merge results in a dict
            data_collector = defaultdict(list)
            for i, k in enumerate(results):
                data_collector[str(i)] = k

        elif self.execute == &#34;sequential&#34;:
            data_collector = defaultdict(list)
            for i in tqdm(
                range(0, repetition),
                desc=&#34;Repeating the simulation...&#34;,
                total=repetition,
                leave=False,
            ):
                data_collector[str(i)] = self.avg_play_help(
                    (
                        network[i],
                        rounds,
                        n_groups,
                        ith_collect,
                        collect_fitness,
                        measure_topology,
                        measure_likelihood_corr,
                        show_no_bar,
                        rnd_fit_init,
                    )
                )

        # Data over the different rounds is averaged and std is computed
        averaged_dict = get_mean_std_over_list(data_collector)
        averaged_dict = concat_df(averaged_dict, rounds)
        return averaged_dict

    def avg_play_help(self, tuple_of_variable: Any) -&gt; DefaultDict[str, List[Any]]:
        &#34;&#34;&#34;Help for the avg_play to return only the default dict.

        Args:
            tuple_of_variable (Any): tuple of variable as required by the play() function.

        Returns:
            DefaultDict[str, List[Any]]: return a dict containing all the measurements.
        &#34;&#34;&#34;
        # Set the seed each time, otherwise the simulation will be exactly the same
        random.seed()
        (
            network,
            rounds,
            n_groups,
            ith_collect,
            collect_fitness,
            measure_topology,
            measure_likelihood_corr,
            show_no_bar,
            rnd_fit_init,
        ) = tuple_of_variable

        _, data_collector = self.play(
            network,
            rounds,
            n_groups,
            ith_collect,
            collect_fitness,
            measure_topology,
            measure_likelihood_corr,
            show_no_bar,
            rnd_fit_init,
        )
        return data_collector

    def investigation_stage(
        self,
        network: gt.Graph,
        group_members: List[int],
        slct_pers: int,
        slct_status: str,
    ) -&gt; Tuple[gt.Graph]:
        &#34;&#34;&#34;Correspond to the investigation stage.

        Given an group, if the victimizer is found, a punishment is conducted
        Args:
            network (gt.Graph): population network with honests,lone wolves and criminals
            group_members (List[int]): list of neighbours of selected person.
            slct_pers (int): person selected in that specific round.
            slct_status (str): selected person&#39;s status.

        Raises:
            warnings.warn: raise warning if neighbours have not the status of either
                                                        honests/lone wolves or criminals.

        Returns:
            Tuple[gt.Graph]: return the population
        &#34;&#34;&#34;
        if slct_status == &#34;h&#34;:
            # No victimizer -&gt;  No punishment
            return network

        # Get the status proportions of the group
        _, _, _, p_c, p_h, _ = self.counting_status_proportions(network, group_members)

        # If victimizer is found, penalties shouldn&#39;t 0.
        # state investigation
        state_penalty = self.conducting_investigation(
            group_members, slct_pers, self.beta_s
        )
        # civil investigation
        civil_penalty = (
            self.conducting_investigation(group_members, slct_pers, self.beta_h) * p_h
        )
        # criminal investigation
        criminal_penalty = (
            self.conducting_investigation(group_members, slct_pers, self.beta_c) * p_c
        )

        if slct_status == &#34;c&#34;:
            # only punish a wolf if he dared to act
            if self.criminal_acting is True:
                # Punish the victimizer
                network.fitness[slct_pers] = (
                    network.fitness[slct_pers] - state_penalty - civil_penalty
                )
                # Punish the partner in crime
                for member in group_members:
                    if network.status[member] == &#34;c&#34; and member != slct_pers:
                        network.fitness[member] = network.fitness[
                            member
                        ] - self.gamma * (state_penalty + civil_penalty)

        elif slct_status == &#34;w&#34;:
            # only punish a wolf if he dared to act
            if self.wolf_acting is True:
                # Punish the victimizer
                network.fitness[slct_pers] = (
                    network.fitness[slct_pers]
                    - state_penalty
                    - civil_penalty
                    - criminal_penalty
                )

        else:
            raise warnings.warn(&#34;slct_status should be either h/w/c...&#34;)

        return network

    def conducting_investigation(
        self, group_members: List[int], slct_pers: int, penalty_score: int
    ) -&gt; int:
        &#34;&#34;&#34;Perform an state investigation.

        Pick a random person, if victimizer is found, penalty is returned

        Args:
            group_members (List[int]): list of neighbours of selcted person.
            slct_pers (int): person selected in that round.
            penalty_score (int): penalty score from either criminals, peer pressure or state.

        Returns:
            int: return penalty_score.
        &#34;&#34;&#34;
        random_picked_person = random.choice(list(group_members))
        if random_picked_person == slct_pers:
            # Found victimizer
            return penalty_score
        elif random_picked_person != slct_pers:
            # Victimizer not found
            return 0
        return None

    def acting_stage(
        self,
        network: gt.Graph,
        slct_pers: int,
        slct_pers_status: str,
        group_members: List[int],
    ) -&gt; Tuple[gt.Graph, int, str]:
        &#34;&#34;&#34;Correspond to the acting stage in the paper.

        Given an group, select on person and proceed to the acting.

        Args:
            network (gt.Graph): population network including honests,lone wolves and criminals
            slct_pers (int): person selected in that round
            slct_pers_status (str): slected person&#39; status.
            group_members (List[int]): list of slected person&#39;s neighbours.

        Raises:
            warnings.warn: raises a warning if neighbours are not honests/lone wolves/criminals.

        Returns:
            Tuple[gt.Graph, int, str]: returns population, selected person and its status.
        &#34;&#34;&#34;
        if slct_pers_status == &#34;h&#34;:
            new_network = self.inflict_damage(
                network, group_members, slct_pers, slct_pers_status
            )
            return network, slct_pers, slct_pers_status
        elif slct_pers_status == &#34;c&#34;:
            new_network = self.inflict_damage(
                network, group_members, slct_pers, slct_pers_status
            )
            return new_network, slct_pers, slct_pers_status
        elif slct_pers_status == &#34;w&#34;:
            new_network = self.inflict_damage(
                network, group_members, slct_pers, slct_pers_status
            )
            return new_network, slct_pers, slct_pers_status
        else:
            raise warnings.warn(
                f&#34;Person status {slct_pers_status} didn&#39;t correspond to h/c/w...&#34;
            )

    def inflict_damage(
        self,
        network: gt.Graph,
        group_members: List[int],
        slct_pers: int,
        slct_pers_status: str,
    ) -&gt; Tuple[gt.Graph]:
        &#34;&#34;&#34;Perform criminal activity.

        Rest of the group gets a damage inflicted.
        If slct_pers is honest, the person gets bonus points for acting good!

        Args:
            network (gt.Graph): population network with honests, lone wolves and criminals.
            group_members (List[int]): list of selected person&#39;s neighbours.
            slct_pers (int): person selected in that round.
            slct_pers_status (str): selected person&#39; status.

        Raises:
            warnings.warn: raises a warning if status is not equal to honest/lone wolf/criminal.

        Returns:
            Tuple[gt.Graph]: returns population.
        &#34;&#34;&#34;
        if slct_pers_status != &#34;h&#34;:
            n_c, n_h, n_w, p_c, p_h, p_w = self.counting_status_proportions(
                network=network, group_members=group_members
            )
        if slct_pers_status == &#34;h&#34;:
            # Bonus points if law-abiding
            network.fitness[slct_pers] = network.fitness[slct_pers] + self.r_h
        elif slct_pers_status == &#34;c&#34;:
            # Inflict damage to all the wolves and honest
            # If only criminals are present in the group
            # then there is no acting
            self.criminal_acting = False
            # Honest and wolves are present
            if p_h + p_w &gt; 0:
                self.criminal_acting = True
            # Inflicting damage to everyone but himself
            if self.criminal_acting is True:
                for member in group_members:
                    if network.status[member] in [&#34;h&#34;, &#34;w&#34;]:
                        network.fitness[member] = network.fitness[member] - self.c_c
                    elif network.status[member] == &#34;c&#34;:
                        network.fitness[member] = network.fitness[member] + (
                            (self.r_c * self.c_c) / n_c
                        )

        elif slct_pers_status == &#34;w&#34;:
            # Decide if lone wolf dares to act
            self.wolf_acting = False
            if random_c() &gt;= 1 - self.delta * (1 - p_c):
                self.wolf_acting = True
            # Inflicting damage to everyone but himself
            if self.wolf_acting is True:
                for member in group_members:
                    if member != slct_pers and network.status[member] in [&#34;h&#34;, &#34;w&#34;]:
                        network.fitness[member] = network.fitness[member] - self.c_w

                    elif member != slct_pers and network.status[member] == &#34;c&#34;:
                        network.fitness[member] = (
                            network.fitness[member]
                            - self.c_w
                            + ((self.tau * (self.r_w * self.c_w)) / n_c)
                        )

                    elif member == slct_pers:
                        network.fitness[member] = network.fitness[member] + (
                            self.r_w * self.c_w
                        )

        else:
            raise warnings.warn(&#34;Person status didn&#39;t correspond to c/w...&#34;)

        return network

    def evolutionary_stage(
        self, network: gt.Graph, slct_person: int, group_members: List[int]
    ) -&gt; Tuple[gt.Graph]:
        &#34;&#34;&#34;Perform the evolutionary stage.

        Randomly picks a two players and performs either mutation
        or a role switch with a certain probability.

        Args:
            network (gt.Graph): population network with honests,lone wolves and criminals.
            slct_person (int): person selected in that round.
            group_members (List[int]): list of person&#39;s neighbours.

        Returns:
            Tuple[gt.Graph]: returns population.
        &#34;&#34;&#34;
        person_a = slct_person
        bucket_list = list(group_members)
        bucket_list.remove(person_a)
        if random_c() &gt; self.mutation_prob and len(bucket_list) != 0:
            # Based on the fermi function will check if an interaction will happen
            person_b = random.choice(bucket_list)
            network = self.interchange_roles(network, person_a, person_b)
        else:
            # Mutation will happen
            network = self.mutation(network, person_a)
        return network

    def counting_status_proportions(
        self, network: gt.Graph, group_members: List
    ) -&gt; Tuple[int, int, int, float, float, float]:
        &#34;&#34;&#34;Return the proportions of criminals,honests and wolves.

        Args:
            network (gt.Graph): population including honests, lone wolves and criminals.
            group_members (List): list of defined persons to take the ratio off.
                                        Normally, the list includes the whole population.

        Returns:
            Tuple[int, int, int, float, float, float]: returns number of criminals/honests/wolves,
                                                        and ratio of criminals/honests/lone wolves,
                                                        in that specific order.
        &#34;&#34;&#34;
        # First get proportions of h/c/w within the group
        size_group = len(group_members)
        unique, counts = np.unique(network.status[group_members], return_counts=True)
        count_dict = dict(zip(unique, counts))

        if &#34;h&#34; in count_dict:
            n_h = int(count_dict[&#34;h&#34;])
        else:
            n_h = 0

        if &#34;c&#34; in count_dict:
            n_c = int(count_dict[&#34;c&#34;])
        else:
            n_c = 0

        if &#34;w&#34; in count_dict:
            n_w = int(count_dict[&#34;w&#34;])
        else:
            n_w = 0

        p_h = n_h / size_group
        p_c = n_c / size_group
        p_w = n_w / size_group
        return n_c, n_h, n_w, p_c, p_h, p_w

    def get_overall_fitness_distribution(
        self, network: gt.Graph
    ) -&gt; Tuple[float, float, float]:
        &#34;&#34;&#34;Get the mean fitness for the different status in a group.

        Args:
            network (gt.Graph): population including the honest,criminals and lone wolves.

        Returns:
            Tuple[float, float, float]: returns mean honest/criminal and lone wolves fitness.
                                        In that order!
        &#34;&#34;&#34;
        h_idx = np.where(network.status == &#34;h&#34;)
        c_idx = np.where(network.status == &#34;c&#34;)
        w_idx = np.where(network.status == &#34;w&#34;)

        mean_h_fit = np.mean(network.fitness[h_idx])
        mean_c_fit = np.mean(network.fitness[c_idx])
        mean_w_fit = np.mean(network.fitness[w_idx])
        return mean_h_fit, mean_c_fit, mean_w_fit

    def slct_pers_n_neighbours(
        self, network: gt.Graph, n_groups: int, network_size: int
    ) -&gt; Dict[int, List[int]]:
        &#34;&#34;&#34;Randomly select the protagonist (person who can act) and its neighbours.

        Args:
            n_groups (int): number of groups to form each round
            network_size (int): get the size of the network to include all the nodes

        Returns:
            Dict[int,List[int]]: key is the protagonist and value is protagonist + neighbors
        &#34;&#34;&#34;
        communities = {}
        protagonists = random.sample(range(0, network_size), n_groups)
        for protagonist in protagonists:
            communities[protagonist] = [protagonist] + list(
                network.get_all_neighbors(protagonist)
            )

        return communities

    def mutation(self, network: gt.Graph, person: int) -&gt; gt.Graph:
        &#34;&#34;&#34;Perform mutation on a given individual.

        Args:
            network (gt.Graph): population with honests,lone wolves and criminals
            person (int): person selected in that round.

        Returns:
            gt.Graph: returns population.
        &#34;&#34;&#34;
        network.status[person] = random.choice([&#34;c&#34;, &#34;h&#34;, &#34;w&#34;])
        return network

    def interchange_roles(
        self,
        network: gt.Graph,
        person_a: int,
        person_b: int,
    ) -&gt; Tuple[gt.Graph]:
        &#34;&#34;&#34;Interchange roles based on Fermi function.

        Args:
            network (gt.Graph): population with honest,lone wolves and criminals.
            person_a (int): person a to copy person b
            person_b (int): person b

        Returns:
            Tuple[gt.Graph]: returns population.
        &#34;&#34;&#34;
        fitness_a = network.fitness[person_a]
        fitness_b = network.fitness[person_b]

        # Probability that a copies b
        if self.fermi_function(fitness_b, fitness_a):
            network.status[person_a] = network.status[person_b]

        return network

    def fermi_function(self, w_j: float, w_i: float) -&gt; bool:
        &#34;&#34;&#34;Return the probability of changing their role.

        Args:
            w_j (float): fitness of person a
            w_i (float): fitness of person b

        Returns:
            bool: returns true if roles are interchanged else flase.
        &#34;&#34;&#34;
        prob = 1 / (np.exp(-(w_j - w_i) / self.temperature) + 1)
        if random_c() &gt; prob:
            return False
        else:
            return True
        return None

    def update_age(self, network: gt.Graph) -&gt; gt.Graph:
        &#34;&#34;&#34;Update the age of a criminal node.

        Basically, count how many rounds a node has a criminal status criminal
        &#34;&#34;&#34;
        idx = np.where(network.status == &#34;c&#34;)
        network.age[idx] = network.age[idx] + 1
        return network

    def update_fitness(self, network: gt.Graph) -&gt; gt.Graph:
        &#34;&#34;&#34;Update the fitness in a decay fashion.&#34;&#34;&#34;
        network.fitness = network.fitness * 0.666
        return network

    def create_likelihood_corr_df(self, network: gt.Graph) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Create a DataFrame of nodes likelihood of being a criminal and its characteristics.&#34;&#34;&#34;
        org_num_threads = gt.openmp_get_num_threads()
        if self.execute == &#34;parallel&#34;:
            gt.openmp_set_num_threads(1)
        network, _ = NodeStats.get_eigenvector_centrality(network)
        network, _ = NodeStats.get_betweenness(network)
        network, _ = NodeStats.get_closeness(network)
        network, _ = NodeStats.get_katz(network)

        if self.execute == &#34;parallel&#34;:
            gt.openmp_set_num_threads(org_num_threads)

        df = pd.DataFrame(
            {
                &#34;criminal_likelihood&#34;: network.age,
                &#34;degree&#34;: network.get_total_degrees(
                    list(range(0, network.num_vertices()))
                ),
                &#34;betweenness&#34;: network.btwn,
                &#34;katz&#34;: network.katz,
                &#34;closeness&#34;: network.closeness,
                &#34;eigen vector&#34;: network.eigen_v,
            }
        )
        df = df.astype(float)
        return df</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="simulators.sim_mart_vaq.SimMartVaq"><code class="flex name class">
<span>class <span class="ident">SimMartVaq</span></span>
<span>(</span><span>network: graph_tool.Graph, delta: float = 0.1, tau: float = 0.1, gamma: float = 0.1, beta_s: int = 1, beta_h: int = 1, beta_c: int = 1, c_w: int = 1, c_c: int = 1, r_w: int = 1, r_c: int = 1, r_h: int = 0, temperature: float = 10, mutation_prob: float = 0.0001, execute: str = 'parallel')</span>
</code></dt>
<dd>
<div class="desc"><p>Contain the framework to simulate the evolutionary dynamic of a criminal network.</p>
<p>Init the network characteristics.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>network</code></strong> :&ensp;<code>gt.Graph</code></dt>
<dd>Initial criminal network</dd>
<dt><strong><code>delta</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Influence of criminals on the acting of the wolf.
Defaults to 0.1.</dd>
<dt>tau (int, optional):Influence of the wolf's action on criminals. Defaults to 0.1.</dt>
<dt><strong><code>gamma</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Punishment ratio for the other members of the criminal
organization. Defaults to 0.1.</dd>
<dt><strong><code>beta_s</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>state punishment value. Defaults to 1.</dd>
<dt><strong><code>beta_h</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Civil punishment value. Defaults to 1.</dd>
<dt><strong><code>beta_c</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Criminal punishment value. Defaults to 1.</dd>
<dt><strong><code>c_w</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Damage caused by wolf. Defaults to 1.</dd>
<dt><strong><code>c_c</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Damage caused by criminal. Defaults to 1.</dd>
<dt><strong><code>r_w</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Reward ratio for wolf. Defaults to 1.</dd>
<dt><strong><code>r_c</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Reward ratio for criminal. Defaults to 1.</dd>
<dt><strong><code>r_h</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Bonus ratio for honest. Defaults to 0.</dd>
<dt><strong><code>temperature</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Temperature used in the fermi function. Defaults to 10.</dd>
<dt><strong><code>mutation_prob</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Mutation probability to either randomly pick a
new status or switch status with an other agent. Defaults to 0.0001.</dd>
<dt><strong><code>execute</code></strong> :&ensp;<code>str</code>,optional</dt>
<dd>Defines if some process should run parallel or sequential.
Default to parallel.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SimMartVaq:
    &#34;&#34;&#34;Contain the framework to simulate the evolutionary dynamic of a criminal network.&#34;&#34;&#34;

    def __init__(
        self,
        network: gt.Graph,
        delta: float = 0.1,
        tau: float = 0.1,
        gamma: float = 0.1,
        beta_s: int = 1,
        beta_h: int = 1,
        beta_c: int = 1,
        c_w: int = 1,
        c_c: int = 1,
        r_w: int = 1,
        r_c: int = 1,
        r_h: int = 0,
        temperature: float = 10,
        mutation_prob: float = 0.0001,
        execute: str = &#34;parallel&#34;,
    ) -&gt; None:
        &#34;&#34;&#34;Init the network characteristics.

        Args:
            network (gt.Graph): Initial criminal network
            delta (int, optional): Influence of criminals on the acting of the wolf.
                                   Defaults to 0.1.
            tau (int, optional):Influence of the wolf&#39;s action on criminals. Defaults to 0.1.
            gamma (float, optional): Punishment ratio for the other members of the criminal
                                                                    organization. Defaults to 0.1.
            beta_s (int, optional): state punishment value. Defaults to 1.
            beta_h (int, optional): Civil punishment value. Defaults to 1.
            beta_c (int, optional): Criminal punishment value. Defaults to 1.
            c_w (int, optional): Damage caused by wolf. Defaults to 1.
            c_c (int, optional): Damage caused by criminal. Defaults to 1.
            r_w (int, optional): Reward ratio for wolf. Defaults to 1.
            r_c (int, optional): Reward ratio for criminal. Defaults to 1.
            r_h (int, optional): Bonus ratio for honest. Defaults to 0.
            temperature (int, optional): Temperature used in the fermi function. Defaults to 10.
            mutation_prob (float, optional): Mutation probability to either randomly pick a
                                new status or switch status with an other agent. Defaults to 0.0001.
            execute (str,optional): Defines if some process should run parallel or sequential.
                                    Default to parallel.
        &#34;&#34;&#34;
        # Define name of simulator
        self._name = &#34;sim_mart_vaq&#34;
        self.network = network
        self.network.status = np.asarray(list(network.vp.status))
        self.network.fitness = np.zeros(network.num_vertices())
        self.network.age = np.zeros(network.num_vertices())

        # Check if data is coherent
        assert isinstance(network, gt.Graph), &#34;Network should be of type gt.&#34;
        assert network.vp.status, &#34;Network has no attribute status&#34;
        self.ratio_honest = (
            len(gt.find_vertex(network, network.vp.status, &#34;h&#34;))
            / self.network.num_vertices()
        )
        self.ratio_wolf = (
            len(gt.find_vertex(network, network.vp.status, &#34;w&#34;))
            / self.network.num_vertices()
        )
        self.ratio_criminal = (
            len(gt.find_vertex(network, network.vp.status, &#34;c&#34;))
            / self.network.num_vertices()
        )

        assert np.isclose(self.ratio_honest + self.ratio_wolf + self.ratio_criminal, 1)

        # Set damaging and punishing parameters
        self.delta = delta
        self.tau = tau
        self.gamma = gamma
        self.beta_s = beta_s
        self.beta_h = beta_h
        self.beta_c = beta_c
        self.c_w = c_w
        self.c_c = c_c
        self.r_w = r_w
        self.r_c = r_c
        self.r_h = r_h

        # Set the fermic temperature &amp; mutation probability
        self.temperature = temperature
        self.mutation_prob = mutation_prob

        # Set the execute, if parallel or sequential
        self.execute = execute

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;Return the name of the simulator.&#34;&#34;&#34;
        return self._name

    def play(
        self,
        network: gt.Graph,
        rounds: int = 1,
        n_groups: int = 1,
        ith_collect: int = 20,
        collect_fitness: bool = True,
        measure_topology: bool = False,
        measure_likelihood_corr: bool = False,
        show_no_bar: bool = True,
        rnd_fit_init: bool = False,
    ) -&gt; Tuple[gt.Graph, DefaultDict[str, List[Any]]]:
        &#34;&#34;&#34;Play the agent-based model.

        Args:
            network (gt.Graph): population including honests,lone actors and criminals.
            rounds (int, optional): number of rounds to play. Defaults to 1.
            n_groups (int, optional): each round select how many people are selected from the pool.
                                    Defaults to 1.
            ith_collect (int, optional): collect ratio every nth round (for speed improvement).
                                        Defaults to 20.
            collect_fitness (bool, optional): collect fitness. Defaults to True.
            measure_topology (bool, optional): collect secrecy,flow of information and giant comp.
                                        Defaults to False.
            measure_likelihood_corr (bool, optional): collect the likelihood of a node to be
                                                        criminal. Defaults to False.
            show_no_bar (bool, optional): show progress bar or not. Defaults to True.
            rnd_fit_init (bool, optional): assign random fitness to nodes. Defaults to False.

        Returns:
            Tuple[gt.Graph, DefaultDict[str, List[Any]]]: returns population and dictionary
                                                                containing all the measurements.
        &#34;&#34;&#34;
        network.status = np.asarray(list(network.vp.status))
        if rnd_fit_init:
            network.fitness = np.random.uniform(50, -50, network.num_vertices())
        else:
            network.fitness = np.zeros(network.num_vertices())
        network.age = np.zeros(network.num_vertices())

        # collectors which collects the ratio and fitness over each iteration
        data_collector = defaultdict(
            list,
            {
                k: []
                for k in (
                    &#34;ratio_honest&#34;,
                    &#34;ratio_criminal&#34;,
                    &#34;ratio_wolf&#34;,
                    &#34;fitness_honest&#34;,
                    &#34;fitness_criminal&#34;,
                    &#34;fitness_wolf&#34;,
                    &#34;secrecy&#34;,
                    &#34;flow_information&#34;,
                    &#34;size_of_largest_component&#34;,
                    &#34;df&#34;,
                )
            },
        )  # type: DefaultDict[str, List[Any]]

        # Run the simulation
        for i in tqdm(
            range(1, rounds + 1),
            desc=&#34;Playing the rounds...&#34;,
            total=rounds,
            leave=False,
            disable=False,
        ):
            # Divide the network in random new groups
            dict_of_group = self.slct_pers_n_neighbours(
                network=network, n_groups=n_groups, network_size=network.num_vertices()
            )

            # Go through each group
            for slct_pers, group_members in dict_of_group.items():

                # Check the person status
                slct_pers_status = network.status[slct_pers]

                # Acting stage
                network, slct_pers, slct_status = self.acting_stage(
                    network, slct_pers, slct_pers_status, group_members
                )
                # Investigation stage
                network = self.investigation_stage(
                    network, group_members, slct_pers, slct_status
                )

            # Divide the network in random new groups for evolutionary process
            dict_of_group_evol = self.slct_pers_n_neighbours(
                network=network,
                n_groups=n_groups,
                network_size=network.num_vertices(),
            )
            # Go through each group
            for slct_pers_evol, group_members_evol in dict_of_group_evol.items():
                # Evolutionary stage
                network = self.evolutionary_stage(
                    network, slct_pers_evol, group_members_evol
                )

            if measure_likelihood_corr:
                network = self.update_age(network)

            # update fitness decay
            network = self.update_fitness(network)

            # Collect the data
            if i % ith_collect == 0 or i == 1:
                _, _, _, p_c, p_h, p_w = self.counting_status_proportions(
                    network=network,
                    group_members=list(range(0, network.num_vertices())),
                )

                data_collector[&#34;iteration&#34;].append(i)
                data_collector[&#34;ratio_honest&#34;].append(p_h)
                data_collector[&#34;ratio_wolf&#34;].append(p_w)
                data_collector[&#34;ratio_criminal&#34;].append(p_c)

                if collect_fitness:
                    (
                        mean_h_fit,
                        mean_c_fit,
                        mean_w_fit,
                    ) = self.get_overall_fitness_distribution(network=network)
                    data_collector[&#34;fitness_honest&#34;].append(mean_h_fit)
                    data_collector[&#34;fitness_criminal&#34;].append(mean_c_fit)
                    data_collector[&#34;fitness_wolf&#34;].append(mean_w_fit)

                if measure_topology:
                    # Extract the criminal network, the filtering is done on the network object
                    logger.info(&#34;Filtering the criminal_network&#34;)
                    NetworkExtractor.filter_criminal_network(network)

                    if network.num_vertices() == 0:
                        logger.info(&#34;No criminals in the network&#34;)
                        logger.info(&#34;Calculating the secrecy&#34;)
                        data_collector[&#34;secrecy&#34;].append(-1)
                        data_collector[&#34;density&#34;].append(0)
                        logger.info(&#34;Calculating the flow of information&#34;)
                        data_collector[&#34;flow_information&#34;].append(0)
                        logger.info(&#34;Calculating the largest_component&#34;)
                        data_collector[&#34;size_of_largest_component&#34;].append(0)

                    elif network.num_vertices() &gt;= 1:
                        logger.info(&#34;Calculating the secrecy&#34;)
                        data_collector[&#34;secrecy&#34;].append(NodeStats.get_secrecy(network))
                        data_collector[&#34;density&#34;].append(NodeStats.get_density(network))
                        logger.info(&#34;Calculating the flow of information&#34;)

                        gsc = gt.extract_largest_component(network)
                        if self.execute == &#34;parallel&#34;:
                            data_collector[&#34;flow_information&#34;].append(
                                NodeStats.get_flow_of_information(gsc)
                            )
                        elif self.execute == &#34;sequential&#34;:
                            # the faster version doesn&#39;t work sequentially
                            data_collector[&#34;flow_information&#34;].append(
                                NodeStats.get_flow_of_information_faster(gsc)
                            )

                        logger.info(&#34;Calculating the largest_component&#34;)
                        data_collector[&#34;size_of_largest_component&#34;].append(
                            NodeStats.get_size_of_largest_component(network)[0]
                        )

                    # Unfilter the network back to its initial configuration
                    logger.info(&#34;UnFiltering the criminal_network&#34;)
                    NetworkExtractor.un_filter_criminal_network(network)

        # Add a df with the likelihood of being a criminal and the node centrality
        if measure_likelihood_corr:
            data_collector[&#34;df&#34;] = self.create_likelihood_corr_df(network)

        gc.collect()
        return network, data_collector

    def avg_play(
        self,
        network: Union[gt.Graph, List[gt.Graph]],
        rounds: int = 1,
        n_groups: int = 20,
        ith_collect: int = 20,
        repetition: int = 20,
        measure_topology: bool = False,
        measure_likelihood_corr: bool = False,
        collect_fitness: bool = False,
        show_no_bar: bool = False,
        rnd_fit_init: bool = False,
    ) -&gt; DefaultDict[str, Union[DefaultDict[Any, Any], List[Any]]]:
        &#34;&#34;&#34;Get the average results of the simulation given the parameters.

        Args:
            network (gt.Graph, List): population or list of population
            rounds (int, optional): Rounds to play in the simulation. Defaults to 1.
            n_groups (int,optional): Number of groups to form each round
            repetition (int, optional): number of repetition of the simulation. Defaults to 20.

        Returns:
            DefaultDict[Union[int, str], Union[DefaultDict,List[Any]]]:
                                                            Returns network and collected data.
        &#34;&#34;&#34;
        # Running multiprocessing
        # If repetition are less than number of cores
        # then don&#39;t use all the cores
        if self.execute == &#34;parallel&#34;:
            if repetition &lt; multiprocessing.cpu_count() - 1:
                num_cpus = repetition
            else:
                num_cpus = multiprocessing.cpu_count() - 3

            if isinstance(network, gt.Graph):
                results = p_umap(
                    self.avg_play_help,
                    (
                        [
                            # arguments need to be in this order
                            (
                                network,
                                rounds,
                                n_groups,
                                ith_collect,
                                collect_fitness,
                                measure_topology,
                                measure_likelihood_corr,
                                show_no_bar,
                                rnd_fit_init,
                            )
                            for i in range(0, repetition)
                        ]
                    ),
                    **{&#34;num_cpus&#34;: num_cpus, &#34;desc&#34;: &#34;Repeating simulation....&#34;},
                )
            elif isinstance(network, list):
                results = p_umap(
                    self.avg_play_help,
                    (
                        [
                            # arguments need to be in this order
                            (
                                network[i],
                                rounds,
                                n_groups,
                                ith_collect,
                                collect_fitness,
                                measure_topology,
                                measure_likelihood_corr,
                                show_no_bar,
                                rnd_fit_init,
                            )
                            for i in range(0, repetition)
                        ]
                    ),
                    **{&#34;num_cpus&#34;: num_cpus, &#34;desc&#34;: &#34;Repeating simulation....&#34;},
                )

            # merge results in a dict
            data_collector = defaultdict(list)
            for i, k in enumerate(results):
                data_collector[str(i)] = k

        elif self.execute == &#34;sequential&#34;:
            data_collector = defaultdict(list)
            for i in tqdm(
                range(0, repetition),
                desc=&#34;Repeating the simulation...&#34;,
                total=repetition,
                leave=False,
            ):
                data_collector[str(i)] = self.avg_play_help(
                    (
                        network[i],
                        rounds,
                        n_groups,
                        ith_collect,
                        collect_fitness,
                        measure_topology,
                        measure_likelihood_corr,
                        show_no_bar,
                        rnd_fit_init,
                    )
                )

        # Data over the different rounds is averaged and std is computed
        averaged_dict = get_mean_std_over_list(data_collector)
        averaged_dict = concat_df(averaged_dict, rounds)
        return averaged_dict

    def avg_play_help(self, tuple_of_variable: Any) -&gt; DefaultDict[str, List[Any]]:
        &#34;&#34;&#34;Help for the avg_play to return only the default dict.

        Args:
            tuple_of_variable (Any): tuple of variable as required by the play() function.

        Returns:
            DefaultDict[str, List[Any]]: return a dict containing all the measurements.
        &#34;&#34;&#34;
        # Set the seed each time, otherwise the simulation will be exactly the same
        random.seed()
        (
            network,
            rounds,
            n_groups,
            ith_collect,
            collect_fitness,
            measure_topology,
            measure_likelihood_corr,
            show_no_bar,
            rnd_fit_init,
        ) = tuple_of_variable

        _, data_collector = self.play(
            network,
            rounds,
            n_groups,
            ith_collect,
            collect_fitness,
            measure_topology,
            measure_likelihood_corr,
            show_no_bar,
            rnd_fit_init,
        )
        return data_collector

    def investigation_stage(
        self,
        network: gt.Graph,
        group_members: List[int],
        slct_pers: int,
        slct_status: str,
    ) -&gt; Tuple[gt.Graph]:
        &#34;&#34;&#34;Correspond to the investigation stage.

        Given an group, if the victimizer is found, a punishment is conducted
        Args:
            network (gt.Graph): population network with honests,lone wolves and criminals
            group_members (List[int]): list of neighbours of selected person.
            slct_pers (int): person selected in that specific round.
            slct_status (str): selected person&#39;s status.

        Raises:
            warnings.warn: raise warning if neighbours have not the status of either
                                                        honests/lone wolves or criminals.

        Returns:
            Tuple[gt.Graph]: return the population
        &#34;&#34;&#34;
        if slct_status == &#34;h&#34;:
            # No victimizer -&gt;  No punishment
            return network

        # Get the status proportions of the group
        _, _, _, p_c, p_h, _ = self.counting_status_proportions(network, group_members)

        # If victimizer is found, penalties shouldn&#39;t 0.
        # state investigation
        state_penalty = self.conducting_investigation(
            group_members, slct_pers, self.beta_s
        )
        # civil investigation
        civil_penalty = (
            self.conducting_investigation(group_members, slct_pers, self.beta_h) * p_h
        )
        # criminal investigation
        criminal_penalty = (
            self.conducting_investigation(group_members, slct_pers, self.beta_c) * p_c
        )

        if slct_status == &#34;c&#34;:
            # only punish a wolf if he dared to act
            if self.criminal_acting is True:
                # Punish the victimizer
                network.fitness[slct_pers] = (
                    network.fitness[slct_pers] - state_penalty - civil_penalty
                )
                # Punish the partner in crime
                for member in group_members:
                    if network.status[member] == &#34;c&#34; and member != slct_pers:
                        network.fitness[member] = network.fitness[
                            member
                        ] - self.gamma * (state_penalty + civil_penalty)

        elif slct_status == &#34;w&#34;:
            # only punish a wolf if he dared to act
            if self.wolf_acting is True:
                # Punish the victimizer
                network.fitness[slct_pers] = (
                    network.fitness[slct_pers]
                    - state_penalty
                    - civil_penalty
                    - criminal_penalty
                )

        else:
            raise warnings.warn(&#34;slct_status should be either h/w/c...&#34;)

        return network

    def conducting_investigation(
        self, group_members: List[int], slct_pers: int, penalty_score: int
    ) -&gt; int:
        &#34;&#34;&#34;Perform an state investigation.

        Pick a random person, if victimizer is found, penalty is returned

        Args:
            group_members (List[int]): list of neighbours of selcted person.
            slct_pers (int): person selected in that round.
            penalty_score (int): penalty score from either criminals, peer pressure or state.

        Returns:
            int: return penalty_score.
        &#34;&#34;&#34;
        random_picked_person = random.choice(list(group_members))
        if random_picked_person == slct_pers:
            # Found victimizer
            return penalty_score
        elif random_picked_person != slct_pers:
            # Victimizer not found
            return 0
        return None

    def acting_stage(
        self,
        network: gt.Graph,
        slct_pers: int,
        slct_pers_status: str,
        group_members: List[int],
    ) -&gt; Tuple[gt.Graph, int, str]:
        &#34;&#34;&#34;Correspond to the acting stage in the paper.

        Given an group, select on person and proceed to the acting.

        Args:
            network (gt.Graph): population network including honests,lone wolves and criminals
            slct_pers (int): person selected in that round
            slct_pers_status (str): slected person&#39; status.
            group_members (List[int]): list of slected person&#39;s neighbours.

        Raises:
            warnings.warn: raises a warning if neighbours are not honests/lone wolves/criminals.

        Returns:
            Tuple[gt.Graph, int, str]: returns population, selected person and its status.
        &#34;&#34;&#34;
        if slct_pers_status == &#34;h&#34;:
            new_network = self.inflict_damage(
                network, group_members, slct_pers, slct_pers_status
            )
            return network, slct_pers, slct_pers_status
        elif slct_pers_status == &#34;c&#34;:
            new_network = self.inflict_damage(
                network, group_members, slct_pers, slct_pers_status
            )
            return new_network, slct_pers, slct_pers_status
        elif slct_pers_status == &#34;w&#34;:
            new_network = self.inflict_damage(
                network, group_members, slct_pers, slct_pers_status
            )
            return new_network, slct_pers, slct_pers_status
        else:
            raise warnings.warn(
                f&#34;Person status {slct_pers_status} didn&#39;t correspond to h/c/w...&#34;
            )

    def inflict_damage(
        self,
        network: gt.Graph,
        group_members: List[int],
        slct_pers: int,
        slct_pers_status: str,
    ) -&gt; Tuple[gt.Graph]:
        &#34;&#34;&#34;Perform criminal activity.

        Rest of the group gets a damage inflicted.
        If slct_pers is honest, the person gets bonus points for acting good!

        Args:
            network (gt.Graph): population network with honests, lone wolves and criminals.
            group_members (List[int]): list of selected person&#39;s neighbours.
            slct_pers (int): person selected in that round.
            slct_pers_status (str): selected person&#39; status.

        Raises:
            warnings.warn: raises a warning if status is not equal to honest/lone wolf/criminal.

        Returns:
            Tuple[gt.Graph]: returns population.
        &#34;&#34;&#34;
        if slct_pers_status != &#34;h&#34;:
            n_c, n_h, n_w, p_c, p_h, p_w = self.counting_status_proportions(
                network=network, group_members=group_members
            )
        if slct_pers_status == &#34;h&#34;:
            # Bonus points if law-abiding
            network.fitness[slct_pers] = network.fitness[slct_pers] + self.r_h
        elif slct_pers_status == &#34;c&#34;:
            # Inflict damage to all the wolves and honest
            # If only criminals are present in the group
            # then there is no acting
            self.criminal_acting = False
            # Honest and wolves are present
            if p_h + p_w &gt; 0:
                self.criminal_acting = True
            # Inflicting damage to everyone but himself
            if self.criminal_acting is True:
                for member in group_members:
                    if network.status[member] in [&#34;h&#34;, &#34;w&#34;]:
                        network.fitness[member] = network.fitness[member] - self.c_c
                    elif network.status[member] == &#34;c&#34;:
                        network.fitness[member] = network.fitness[member] + (
                            (self.r_c * self.c_c) / n_c
                        )

        elif slct_pers_status == &#34;w&#34;:
            # Decide if lone wolf dares to act
            self.wolf_acting = False
            if random_c() &gt;= 1 - self.delta * (1 - p_c):
                self.wolf_acting = True
            # Inflicting damage to everyone but himself
            if self.wolf_acting is True:
                for member in group_members:
                    if member != slct_pers and network.status[member] in [&#34;h&#34;, &#34;w&#34;]:
                        network.fitness[member] = network.fitness[member] - self.c_w

                    elif member != slct_pers and network.status[member] == &#34;c&#34;:
                        network.fitness[member] = (
                            network.fitness[member]
                            - self.c_w
                            + ((self.tau * (self.r_w * self.c_w)) / n_c)
                        )

                    elif member == slct_pers:
                        network.fitness[member] = network.fitness[member] + (
                            self.r_w * self.c_w
                        )

        else:
            raise warnings.warn(&#34;Person status didn&#39;t correspond to c/w...&#34;)

        return network

    def evolutionary_stage(
        self, network: gt.Graph, slct_person: int, group_members: List[int]
    ) -&gt; Tuple[gt.Graph]:
        &#34;&#34;&#34;Perform the evolutionary stage.

        Randomly picks a two players and performs either mutation
        or a role switch with a certain probability.

        Args:
            network (gt.Graph): population network with honests,lone wolves and criminals.
            slct_person (int): person selected in that round.
            group_members (List[int]): list of person&#39;s neighbours.

        Returns:
            Tuple[gt.Graph]: returns population.
        &#34;&#34;&#34;
        person_a = slct_person
        bucket_list = list(group_members)
        bucket_list.remove(person_a)
        if random_c() &gt; self.mutation_prob and len(bucket_list) != 0:
            # Based on the fermi function will check if an interaction will happen
            person_b = random.choice(bucket_list)
            network = self.interchange_roles(network, person_a, person_b)
        else:
            # Mutation will happen
            network = self.mutation(network, person_a)
        return network

    def counting_status_proportions(
        self, network: gt.Graph, group_members: List
    ) -&gt; Tuple[int, int, int, float, float, float]:
        &#34;&#34;&#34;Return the proportions of criminals,honests and wolves.

        Args:
            network (gt.Graph): population including honests, lone wolves and criminals.
            group_members (List): list of defined persons to take the ratio off.
                                        Normally, the list includes the whole population.

        Returns:
            Tuple[int, int, int, float, float, float]: returns number of criminals/honests/wolves,
                                                        and ratio of criminals/honests/lone wolves,
                                                        in that specific order.
        &#34;&#34;&#34;
        # First get proportions of h/c/w within the group
        size_group = len(group_members)
        unique, counts = np.unique(network.status[group_members], return_counts=True)
        count_dict = dict(zip(unique, counts))

        if &#34;h&#34; in count_dict:
            n_h = int(count_dict[&#34;h&#34;])
        else:
            n_h = 0

        if &#34;c&#34; in count_dict:
            n_c = int(count_dict[&#34;c&#34;])
        else:
            n_c = 0

        if &#34;w&#34; in count_dict:
            n_w = int(count_dict[&#34;w&#34;])
        else:
            n_w = 0

        p_h = n_h / size_group
        p_c = n_c / size_group
        p_w = n_w / size_group
        return n_c, n_h, n_w, p_c, p_h, p_w

    def get_overall_fitness_distribution(
        self, network: gt.Graph
    ) -&gt; Tuple[float, float, float]:
        &#34;&#34;&#34;Get the mean fitness for the different status in a group.

        Args:
            network (gt.Graph): population including the honest,criminals and lone wolves.

        Returns:
            Tuple[float, float, float]: returns mean honest/criminal and lone wolves fitness.
                                        In that order!
        &#34;&#34;&#34;
        h_idx = np.where(network.status == &#34;h&#34;)
        c_idx = np.where(network.status == &#34;c&#34;)
        w_idx = np.where(network.status == &#34;w&#34;)

        mean_h_fit = np.mean(network.fitness[h_idx])
        mean_c_fit = np.mean(network.fitness[c_idx])
        mean_w_fit = np.mean(network.fitness[w_idx])
        return mean_h_fit, mean_c_fit, mean_w_fit

    def slct_pers_n_neighbours(
        self, network: gt.Graph, n_groups: int, network_size: int
    ) -&gt; Dict[int, List[int]]:
        &#34;&#34;&#34;Randomly select the protagonist (person who can act) and its neighbours.

        Args:
            n_groups (int): number of groups to form each round
            network_size (int): get the size of the network to include all the nodes

        Returns:
            Dict[int,List[int]]: key is the protagonist and value is protagonist + neighbors
        &#34;&#34;&#34;
        communities = {}
        protagonists = random.sample(range(0, network_size), n_groups)
        for protagonist in protagonists:
            communities[protagonist] = [protagonist] + list(
                network.get_all_neighbors(protagonist)
            )

        return communities

    def mutation(self, network: gt.Graph, person: int) -&gt; gt.Graph:
        &#34;&#34;&#34;Perform mutation on a given individual.

        Args:
            network (gt.Graph): population with honests,lone wolves and criminals
            person (int): person selected in that round.

        Returns:
            gt.Graph: returns population.
        &#34;&#34;&#34;
        network.status[person] = random.choice([&#34;c&#34;, &#34;h&#34;, &#34;w&#34;])
        return network

    def interchange_roles(
        self,
        network: gt.Graph,
        person_a: int,
        person_b: int,
    ) -&gt; Tuple[gt.Graph]:
        &#34;&#34;&#34;Interchange roles based on Fermi function.

        Args:
            network (gt.Graph): population with honest,lone wolves and criminals.
            person_a (int): person a to copy person b
            person_b (int): person b

        Returns:
            Tuple[gt.Graph]: returns population.
        &#34;&#34;&#34;
        fitness_a = network.fitness[person_a]
        fitness_b = network.fitness[person_b]

        # Probability that a copies b
        if self.fermi_function(fitness_b, fitness_a):
            network.status[person_a] = network.status[person_b]

        return network

    def fermi_function(self, w_j: float, w_i: float) -&gt; bool:
        &#34;&#34;&#34;Return the probability of changing their role.

        Args:
            w_j (float): fitness of person a
            w_i (float): fitness of person b

        Returns:
            bool: returns true if roles are interchanged else flase.
        &#34;&#34;&#34;
        prob = 1 / (np.exp(-(w_j - w_i) / self.temperature) + 1)
        if random_c() &gt; prob:
            return False
        else:
            return True
        return None

    def update_age(self, network: gt.Graph) -&gt; gt.Graph:
        &#34;&#34;&#34;Update the age of a criminal node.

        Basically, count how many rounds a node has a criminal status criminal
        &#34;&#34;&#34;
        idx = np.where(network.status == &#34;c&#34;)
        network.age[idx] = network.age[idx] + 1
        return network

    def update_fitness(self, network: gt.Graph) -&gt; gt.Graph:
        &#34;&#34;&#34;Update the fitness in a decay fashion.&#34;&#34;&#34;
        network.fitness = network.fitness * 0.666
        return network

    def create_likelihood_corr_df(self, network: gt.Graph) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Create a DataFrame of nodes likelihood of being a criminal and its characteristics.&#34;&#34;&#34;
        org_num_threads = gt.openmp_get_num_threads()
        if self.execute == &#34;parallel&#34;:
            gt.openmp_set_num_threads(1)
        network, _ = NodeStats.get_eigenvector_centrality(network)
        network, _ = NodeStats.get_betweenness(network)
        network, _ = NodeStats.get_closeness(network)
        network, _ = NodeStats.get_katz(network)

        if self.execute == &#34;parallel&#34;:
            gt.openmp_set_num_threads(org_num_threads)

        df = pd.DataFrame(
            {
                &#34;criminal_likelihood&#34;: network.age,
                &#34;degree&#34;: network.get_total_degrees(
                    list(range(0, network.num_vertices()))
                ),
                &#34;betweenness&#34;: network.btwn,
                &#34;katz&#34;: network.katz,
                &#34;closeness&#34;: network.closeness,
                &#34;eigen vector&#34;: network.eigen_v,
            }
        )
        df = df.astype(float)
        return df</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="simulators.sim_mart_vaq.SimMartVaq.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"><p>Return the name of the simulator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    &#34;&#34;&#34;Return the name of the simulator.&#34;&#34;&#34;
    return self._name</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="simulators.sim_mart_vaq.SimMartVaq.acting_stage"><code class="name flex">
<span>def <span class="ident">acting_stage</span></span>(<span>self, network: graph_tool.Graph, slct_pers: int, slct_pers_status: str, group_members: List[int]) ‑> Tuple[graph_tool.Graph, int, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Correspond to the acting stage in the paper.</p>
<p>Given an group, select on person and proceed to the acting.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>network</code></strong> :&ensp;<code>gt.Graph</code></dt>
<dd>population network including honests,lone wolves and criminals</dd>
<dt><strong><code>slct_pers</code></strong> :&ensp;<code>int</code></dt>
<dd>person selected in that round</dd>
<dt><strong><code>slct_pers_status</code></strong> :&ensp;<code>str</code></dt>
<dd>slected person' status.</dd>
<dt><strong><code>group_members</code></strong> :&ensp;<code>List[int]</code></dt>
<dd>list of slected person's neighbours.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>warnings.warn</code></dt>
<dd>raises a warning if neighbours are not honests/lone wolves/criminals.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[gt.Graph, int, str]</code></dt>
<dd>returns population, selected person and its status.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def acting_stage(
    self,
    network: gt.Graph,
    slct_pers: int,
    slct_pers_status: str,
    group_members: List[int],
) -&gt; Tuple[gt.Graph, int, str]:
    &#34;&#34;&#34;Correspond to the acting stage in the paper.

    Given an group, select on person and proceed to the acting.

    Args:
        network (gt.Graph): population network including honests,lone wolves and criminals
        slct_pers (int): person selected in that round
        slct_pers_status (str): slected person&#39; status.
        group_members (List[int]): list of slected person&#39;s neighbours.

    Raises:
        warnings.warn: raises a warning if neighbours are not honests/lone wolves/criminals.

    Returns:
        Tuple[gt.Graph, int, str]: returns population, selected person and its status.
    &#34;&#34;&#34;
    if slct_pers_status == &#34;h&#34;:
        new_network = self.inflict_damage(
            network, group_members, slct_pers, slct_pers_status
        )
        return network, slct_pers, slct_pers_status
    elif slct_pers_status == &#34;c&#34;:
        new_network = self.inflict_damage(
            network, group_members, slct_pers, slct_pers_status
        )
        return new_network, slct_pers, slct_pers_status
    elif slct_pers_status == &#34;w&#34;:
        new_network = self.inflict_damage(
            network, group_members, slct_pers, slct_pers_status
        )
        return new_network, slct_pers, slct_pers_status
    else:
        raise warnings.warn(
            f&#34;Person status {slct_pers_status} didn&#39;t correspond to h/c/w...&#34;
        )</code></pre>
</details>
</dd>
<dt id="simulators.sim_mart_vaq.SimMartVaq.avg_play"><code class="name flex">
<span>def <span class="ident">avg_play</span></span>(<span>self, network: Union[graph_tool.Graph, List[graph_tool.Graph]], rounds: int = 1, n_groups: int = 20, ith_collect: int = 20, repetition: int = 20, measure_topology: bool = False, measure_likelihood_corr: bool = False, collect_fitness: bool = False, show_no_bar: bool = False, rnd_fit_init: bool = False) ‑> DefaultDict[str, Union[DefaultDict[Any, Any], List[Any]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the average results of the simulation given the parameters.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>network</code></strong> :&ensp;<code>gt.Graph, List</code></dt>
<dd>population or list of population</dd>
<dt><strong><code>rounds</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Rounds to play in the simulation. Defaults to 1.</dd>
<dt><strong><code>n_groups</code></strong> :&ensp;<code>int</code>,optional</dt>
<dd>Number of groups to form each round</dd>
<dt><strong><code>repetition</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>number of repetition of the simulation. Defaults to 20.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>DefaultDict[Union[int, str], Union[DefaultDict,List[Any]]]:
Returns network and collected data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def avg_play(
    self,
    network: Union[gt.Graph, List[gt.Graph]],
    rounds: int = 1,
    n_groups: int = 20,
    ith_collect: int = 20,
    repetition: int = 20,
    measure_topology: bool = False,
    measure_likelihood_corr: bool = False,
    collect_fitness: bool = False,
    show_no_bar: bool = False,
    rnd_fit_init: bool = False,
) -&gt; DefaultDict[str, Union[DefaultDict[Any, Any], List[Any]]]:
    &#34;&#34;&#34;Get the average results of the simulation given the parameters.

    Args:
        network (gt.Graph, List): population or list of population
        rounds (int, optional): Rounds to play in the simulation. Defaults to 1.
        n_groups (int,optional): Number of groups to form each round
        repetition (int, optional): number of repetition of the simulation. Defaults to 20.

    Returns:
        DefaultDict[Union[int, str], Union[DefaultDict,List[Any]]]:
                                                        Returns network and collected data.
    &#34;&#34;&#34;
    # Running multiprocessing
    # If repetition are less than number of cores
    # then don&#39;t use all the cores
    if self.execute == &#34;parallel&#34;:
        if repetition &lt; multiprocessing.cpu_count() - 1:
            num_cpus = repetition
        else:
            num_cpus = multiprocessing.cpu_count() - 3

        if isinstance(network, gt.Graph):
            results = p_umap(
                self.avg_play_help,
                (
                    [
                        # arguments need to be in this order
                        (
                            network,
                            rounds,
                            n_groups,
                            ith_collect,
                            collect_fitness,
                            measure_topology,
                            measure_likelihood_corr,
                            show_no_bar,
                            rnd_fit_init,
                        )
                        for i in range(0, repetition)
                    ]
                ),
                **{&#34;num_cpus&#34;: num_cpus, &#34;desc&#34;: &#34;Repeating simulation....&#34;},
            )
        elif isinstance(network, list):
            results = p_umap(
                self.avg_play_help,
                (
                    [
                        # arguments need to be in this order
                        (
                            network[i],
                            rounds,
                            n_groups,
                            ith_collect,
                            collect_fitness,
                            measure_topology,
                            measure_likelihood_corr,
                            show_no_bar,
                            rnd_fit_init,
                        )
                        for i in range(0, repetition)
                    ]
                ),
                **{&#34;num_cpus&#34;: num_cpus, &#34;desc&#34;: &#34;Repeating simulation....&#34;},
            )

        # merge results in a dict
        data_collector = defaultdict(list)
        for i, k in enumerate(results):
            data_collector[str(i)] = k

    elif self.execute == &#34;sequential&#34;:
        data_collector = defaultdict(list)
        for i in tqdm(
            range(0, repetition),
            desc=&#34;Repeating the simulation...&#34;,
            total=repetition,
            leave=False,
        ):
            data_collector[str(i)] = self.avg_play_help(
                (
                    network[i],
                    rounds,
                    n_groups,
                    ith_collect,
                    collect_fitness,
                    measure_topology,
                    measure_likelihood_corr,
                    show_no_bar,
                    rnd_fit_init,
                )
            )

    # Data over the different rounds is averaged and std is computed
    averaged_dict = get_mean_std_over_list(data_collector)
    averaged_dict = concat_df(averaged_dict, rounds)
    return averaged_dict</code></pre>
</details>
</dd>
<dt id="simulators.sim_mart_vaq.SimMartVaq.avg_play_help"><code class="name flex">
<span>def <span class="ident">avg_play_help</span></span>(<span>self, tuple_of_variable: Any) ‑> DefaultDict[str, List[Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Help for the avg_play to return only the default dict.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tuple_of_variable</code></strong> :&ensp;<code>Any</code></dt>
<dd>tuple of variable as required by the play() function.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DefaultDict[str, List[Any]]</code></dt>
<dd>return a dict containing all the measurements.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def avg_play_help(self, tuple_of_variable: Any) -&gt; DefaultDict[str, List[Any]]:
    &#34;&#34;&#34;Help for the avg_play to return only the default dict.

    Args:
        tuple_of_variable (Any): tuple of variable as required by the play() function.

    Returns:
        DefaultDict[str, List[Any]]: return a dict containing all the measurements.
    &#34;&#34;&#34;
    # Set the seed each time, otherwise the simulation will be exactly the same
    random.seed()
    (
        network,
        rounds,
        n_groups,
        ith_collect,
        collect_fitness,
        measure_topology,
        measure_likelihood_corr,
        show_no_bar,
        rnd_fit_init,
    ) = tuple_of_variable

    _, data_collector = self.play(
        network,
        rounds,
        n_groups,
        ith_collect,
        collect_fitness,
        measure_topology,
        measure_likelihood_corr,
        show_no_bar,
        rnd_fit_init,
    )
    return data_collector</code></pre>
</details>
</dd>
<dt id="simulators.sim_mart_vaq.SimMartVaq.conducting_investigation"><code class="name flex">
<span>def <span class="ident">conducting_investigation</span></span>(<span>self, group_members: List[int], slct_pers: int, penalty_score: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Perform an state investigation.</p>
<p>Pick a random person, if victimizer is found, penalty is returned</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>group_members</code></strong> :&ensp;<code>List[int]</code></dt>
<dd>list of neighbours of selcted person.</dd>
<dt><strong><code>slct_pers</code></strong> :&ensp;<code>int</code></dt>
<dd>person selected in that round.</dd>
<dt><strong><code>penalty_score</code></strong> :&ensp;<code>int</code></dt>
<dd>penalty score from either criminals, peer pressure or state.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>return penalty_score.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conducting_investigation(
    self, group_members: List[int], slct_pers: int, penalty_score: int
) -&gt; int:
    &#34;&#34;&#34;Perform an state investigation.

    Pick a random person, if victimizer is found, penalty is returned

    Args:
        group_members (List[int]): list of neighbours of selcted person.
        slct_pers (int): person selected in that round.
        penalty_score (int): penalty score from either criminals, peer pressure or state.

    Returns:
        int: return penalty_score.
    &#34;&#34;&#34;
    random_picked_person = random.choice(list(group_members))
    if random_picked_person == slct_pers:
        # Found victimizer
        return penalty_score
    elif random_picked_person != slct_pers:
        # Victimizer not found
        return 0
    return None</code></pre>
</details>
</dd>
<dt id="simulators.sim_mart_vaq.SimMartVaq.counting_status_proportions"><code class="name flex">
<span>def <span class="ident">counting_status_proportions</span></span>(<span>self, network: graph_tool.Graph, group_members: List[~T]) ‑> Tuple[int, int, int, float, float, float]</span>
</code></dt>
<dd>
<div class="desc"><p>Return the proportions of criminals,honests and wolves.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>network</code></strong> :&ensp;<code>gt.Graph</code></dt>
<dd>population including honests, lone wolves and criminals.</dd>
<dt><strong><code>group_members</code></strong> :&ensp;<code>List</code></dt>
<dd>list of defined persons to take the ratio off.
Normally, the list includes the whole population.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[int, int, int, float, float, float]</code></dt>
<dd>returns number of criminals/honests/wolves,
and ratio of criminals/honests/lone wolves,
in that specific order.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def counting_status_proportions(
    self, network: gt.Graph, group_members: List
) -&gt; Tuple[int, int, int, float, float, float]:
    &#34;&#34;&#34;Return the proportions of criminals,honests and wolves.

    Args:
        network (gt.Graph): population including honests, lone wolves and criminals.
        group_members (List): list of defined persons to take the ratio off.
                                    Normally, the list includes the whole population.

    Returns:
        Tuple[int, int, int, float, float, float]: returns number of criminals/honests/wolves,
                                                    and ratio of criminals/honests/lone wolves,
                                                    in that specific order.
    &#34;&#34;&#34;
    # First get proportions of h/c/w within the group
    size_group = len(group_members)
    unique, counts = np.unique(network.status[group_members], return_counts=True)
    count_dict = dict(zip(unique, counts))

    if &#34;h&#34; in count_dict:
        n_h = int(count_dict[&#34;h&#34;])
    else:
        n_h = 0

    if &#34;c&#34; in count_dict:
        n_c = int(count_dict[&#34;c&#34;])
    else:
        n_c = 0

    if &#34;w&#34; in count_dict:
        n_w = int(count_dict[&#34;w&#34;])
    else:
        n_w = 0

    p_h = n_h / size_group
    p_c = n_c / size_group
    p_w = n_w / size_group
    return n_c, n_h, n_w, p_c, p_h, p_w</code></pre>
</details>
</dd>
<dt id="simulators.sim_mart_vaq.SimMartVaq.create_likelihood_corr_df"><code class="name flex">
<span>def <span class="ident">create_likelihood_corr_df</span></span>(<span>self, network: graph_tool.Graph) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Create a DataFrame of nodes likelihood of being a criminal and its characteristics.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_likelihood_corr_df(self, network: gt.Graph) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Create a DataFrame of nodes likelihood of being a criminal and its characteristics.&#34;&#34;&#34;
    org_num_threads = gt.openmp_get_num_threads()
    if self.execute == &#34;parallel&#34;:
        gt.openmp_set_num_threads(1)
    network, _ = NodeStats.get_eigenvector_centrality(network)
    network, _ = NodeStats.get_betweenness(network)
    network, _ = NodeStats.get_closeness(network)
    network, _ = NodeStats.get_katz(network)

    if self.execute == &#34;parallel&#34;:
        gt.openmp_set_num_threads(org_num_threads)

    df = pd.DataFrame(
        {
            &#34;criminal_likelihood&#34;: network.age,
            &#34;degree&#34;: network.get_total_degrees(
                list(range(0, network.num_vertices()))
            ),
            &#34;betweenness&#34;: network.btwn,
            &#34;katz&#34;: network.katz,
            &#34;closeness&#34;: network.closeness,
            &#34;eigen vector&#34;: network.eigen_v,
        }
    )
    df = df.astype(float)
    return df</code></pre>
</details>
</dd>
<dt id="simulators.sim_mart_vaq.SimMartVaq.evolutionary_stage"><code class="name flex">
<span>def <span class="ident">evolutionary_stage</span></span>(<span>self, network: graph_tool.Graph, slct_person: int, group_members: List[int]) ‑> Tuple[graph_tool.Graph]</span>
</code></dt>
<dd>
<div class="desc"><p>Perform the evolutionary stage.</p>
<p>Randomly picks a two players and performs either mutation
or a role switch with a certain probability.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>network</code></strong> :&ensp;<code>gt.Graph</code></dt>
<dd>population network with honests,lone wolves and criminals.</dd>
<dt><strong><code>slct_person</code></strong> :&ensp;<code>int</code></dt>
<dd>person selected in that round.</dd>
<dt><strong><code>group_members</code></strong> :&ensp;<code>List[int]</code></dt>
<dd>list of person's neighbours.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[gt.Graph]</code></dt>
<dd>returns population.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evolutionary_stage(
    self, network: gt.Graph, slct_person: int, group_members: List[int]
) -&gt; Tuple[gt.Graph]:
    &#34;&#34;&#34;Perform the evolutionary stage.

    Randomly picks a two players and performs either mutation
    or a role switch with a certain probability.

    Args:
        network (gt.Graph): population network with honests,lone wolves and criminals.
        slct_person (int): person selected in that round.
        group_members (List[int]): list of person&#39;s neighbours.

    Returns:
        Tuple[gt.Graph]: returns population.
    &#34;&#34;&#34;
    person_a = slct_person
    bucket_list = list(group_members)
    bucket_list.remove(person_a)
    if random_c() &gt; self.mutation_prob and len(bucket_list) != 0:
        # Based on the fermi function will check if an interaction will happen
        person_b = random.choice(bucket_list)
        network = self.interchange_roles(network, person_a, person_b)
    else:
        # Mutation will happen
        network = self.mutation(network, person_a)
    return network</code></pre>
</details>
</dd>
<dt id="simulators.sim_mart_vaq.SimMartVaq.fermi_function"><code class="name flex">
<span>def <span class="ident">fermi_function</span></span>(<span>self, w_j: float, w_i: float) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Return the probability of changing their role.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>w_j</code></strong> :&ensp;<code>float</code></dt>
<dd>fitness of person a</dd>
<dt><strong><code>w_i</code></strong> :&ensp;<code>float</code></dt>
<dd>fitness of person b</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>returns true if roles are interchanged else flase.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fermi_function(self, w_j: float, w_i: float) -&gt; bool:
    &#34;&#34;&#34;Return the probability of changing their role.

    Args:
        w_j (float): fitness of person a
        w_i (float): fitness of person b

    Returns:
        bool: returns true if roles are interchanged else flase.
    &#34;&#34;&#34;
    prob = 1 / (np.exp(-(w_j - w_i) / self.temperature) + 1)
    if random_c() &gt; prob:
        return False
    else:
        return True
    return None</code></pre>
</details>
</dd>
<dt id="simulators.sim_mart_vaq.SimMartVaq.get_overall_fitness_distribution"><code class="name flex">
<span>def <span class="ident">get_overall_fitness_distribution</span></span>(<span>self, network: graph_tool.Graph) ‑> Tuple[float, float, float]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the mean fitness for the different status in a group.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>network</code></strong> :&ensp;<code>gt.Graph</code></dt>
<dd>population including the honest,criminals and lone wolves.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[float, float, float]</code></dt>
<dd>returns mean honest/criminal and lone wolves fitness.
In that order!</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_overall_fitness_distribution(
    self, network: gt.Graph
) -&gt; Tuple[float, float, float]:
    &#34;&#34;&#34;Get the mean fitness for the different status in a group.

    Args:
        network (gt.Graph): population including the honest,criminals and lone wolves.

    Returns:
        Tuple[float, float, float]: returns mean honest/criminal and lone wolves fitness.
                                    In that order!
    &#34;&#34;&#34;
    h_idx = np.where(network.status == &#34;h&#34;)
    c_idx = np.where(network.status == &#34;c&#34;)
    w_idx = np.where(network.status == &#34;w&#34;)

    mean_h_fit = np.mean(network.fitness[h_idx])
    mean_c_fit = np.mean(network.fitness[c_idx])
    mean_w_fit = np.mean(network.fitness[w_idx])
    return mean_h_fit, mean_c_fit, mean_w_fit</code></pre>
</details>
</dd>
<dt id="simulators.sim_mart_vaq.SimMartVaq.inflict_damage"><code class="name flex">
<span>def <span class="ident">inflict_damage</span></span>(<span>self, network: graph_tool.Graph, group_members: List[int], slct_pers: int, slct_pers_status: str) ‑> Tuple[graph_tool.Graph]</span>
</code></dt>
<dd>
<div class="desc"><p>Perform criminal activity.</p>
<p>Rest of the group gets a damage inflicted.
If slct_pers is honest, the person gets bonus points for acting good!</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>network</code></strong> :&ensp;<code>gt.Graph</code></dt>
<dd>population network with honests, lone wolves and criminals.</dd>
<dt><strong><code>group_members</code></strong> :&ensp;<code>List[int]</code></dt>
<dd>list of selected person's neighbours.</dd>
<dt><strong><code>slct_pers</code></strong> :&ensp;<code>int</code></dt>
<dd>person selected in that round.</dd>
<dt><strong><code>slct_pers_status</code></strong> :&ensp;<code>str</code></dt>
<dd>selected person' status.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>warnings.warn</code></dt>
<dd>raises a warning if status is not equal to honest/lone wolf/criminal.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[gt.Graph]</code></dt>
<dd>returns population.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inflict_damage(
    self,
    network: gt.Graph,
    group_members: List[int],
    slct_pers: int,
    slct_pers_status: str,
) -&gt; Tuple[gt.Graph]:
    &#34;&#34;&#34;Perform criminal activity.

    Rest of the group gets a damage inflicted.
    If slct_pers is honest, the person gets bonus points for acting good!

    Args:
        network (gt.Graph): population network with honests, lone wolves and criminals.
        group_members (List[int]): list of selected person&#39;s neighbours.
        slct_pers (int): person selected in that round.
        slct_pers_status (str): selected person&#39; status.

    Raises:
        warnings.warn: raises a warning if status is not equal to honest/lone wolf/criminal.

    Returns:
        Tuple[gt.Graph]: returns population.
    &#34;&#34;&#34;
    if slct_pers_status != &#34;h&#34;:
        n_c, n_h, n_w, p_c, p_h, p_w = self.counting_status_proportions(
            network=network, group_members=group_members
        )
    if slct_pers_status == &#34;h&#34;:
        # Bonus points if law-abiding
        network.fitness[slct_pers] = network.fitness[slct_pers] + self.r_h
    elif slct_pers_status == &#34;c&#34;:
        # Inflict damage to all the wolves and honest
        # If only criminals are present in the group
        # then there is no acting
        self.criminal_acting = False
        # Honest and wolves are present
        if p_h + p_w &gt; 0:
            self.criminal_acting = True
        # Inflicting damage to everyone but himself
        if self.criminal_acting is True:
            for member in group_members:
                if network.status[member] in [&#34;h&#34;, &#34;w&#34;]:
                    network.fitness[member] = network.fitness[member] - self.c_c
                elif network.status[member] == &#34;c&#34;:
                    network.fitness[member] = network.fitness[member] + (
                        (self.r_c * self.c_c) / n_c
                    )

    elif slct_pers_status == &#34;w&#34;:
        # Decide if lone wolf dares to act
        self.wolf_acting = False
        if random_c() &gt;= 1 - self.delta * (1 - p_c):
            self.wolf_acting = True
        # Inflicting damage to everyone but himself
        if self.wolf_acting is True:
            for member in group_members:
                if member != slct_pers and network.status[member] in [&#34;h&#34;, &#34;w&#34;]:
                    network.fitness[member] = network.fitness[member] - self.c_w

                elif member != slct_pers and network.status[member] == &#34;c&#34;:
                    network.fitness[member] = (
                        network.fitness[member]
                        - self.c_w
                        + ((self.tau * (self.r_w * self.c_w)) / n_c)
                    )

                elif member == slct_pers:
                    network.fitness[member] = network.fitness[member] + (
                        self.r_w * self.c_w
                    )

    else:
        raise warnings.warn(&#34;Person status didn&#39;t correspond to c/w...&#34;)

    return network</code></pre>
</details>
</dd>
<dt id="simulators.sim_mart_vaq.SimMartVaq.interchange_roles"><code class="name flex">
<span>def <span class="ident">interchange_roles</span></span>(<span>self, network: graph_tool.Graph, person_a: int, person_b: int) ‑> Tuple[graph_tool.Graph]</span>
</code></dt>
<dd>
<div class="desc"><p>Interchange roles based on Fermi function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>network</code></strong> :&ensp;<code>gt.Graph</code></dt>
<dd>population with honest,lone wolves and criminals.</dd>
<dt><strong><code>person_a</code></strong> :&ensp;<code>int</code></dt>
<dd>person a to copy person b</dd>
<dt><strong><code>person_b</code></strong> :&ensp;<code>int</code></dt>
<dd>person b</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[gt.Graph]</code></dt>
<dd>returns population.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interchange_roles(
    self,
    network: gt.Graph,
    person_a: int,
    person_b: int,
) -&gt; Tuple[gt.Graph]:
    &#34;&#34;&#34;Interchange roles based on Fermi function.

    Args:
        network (gt.Graph): population with honest,lone wolves and criminals.
        person_a (int): person a to copy person b
        person_b (int): person b

    Returns:
        Tuple[gt.Graph]: returns population.
    &#34;&#34;&#34;
    fitness_a = network.fitness[person_a]
    fitness_b = network.fitness[person_b]

    # Probability that a copies b
    if self.fermi_function(fitness_b, fitness_a):
        network.status[person_a] = network.status[person_b]

    return network</code></pre>
</details>
</dd>
<dt id="simulators.sim_mart_vaq.SimMartVaq.investigation_stage"><code class="name flex">
<span>def <span class="ident">investigation_stage</span></span>(<span>self, network: graph_tool.Graph, group_members: List[int], slct_pers: int, slct_status: str) ‑> Tuple[graph_tool.Graph]</span>
</code></dt>
<dd>
<div class="desc"><p>Correspond to the investigation stage.</p>
<p>Given an group, if the victimizer is found, a punishment is conducted</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>network</code></strong> :&ensp;<code>gt.Graph</code></dt>
<dd>population network with honests,lone wolves and criminals</dd>
<dt><strong><code>group_members</code></strong> :&ensp;<code>List[int]</code></dt>
<dd>list of neighbours of selected person.</dd>
<dt><strong><code>slct_pers</code></strong> :&ensp;<code>int</code></dt>
<dd>person selected in that specific round.</dd>
<dt><strong><code>slct_status</code></strong> :&ensp;<code>str</code></dt>
<dd>selected person's status.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>warnings.warn</code></dt>
<dd>raise warning if neighbours have not the status of either
honests/lone wolves or criminals.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[gt.Graph]</code></dt>
<dd>return the population</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def investigation_stage(
    self,
    network: gt.Graph,
    group_members: List[int],
    slct_pers: int,
    slct_status: str,
) -&gt; Tuple[gt.Graph]:
    &#34;&#34;&#34;Correspond to the investigation stage.

    Given an group, if the victimizer is found, a punishment is conducted
    Args:
        network (gt.Graph): population network with honests,lone wolves and criminals
        group_members (List[int]): list of neighbours of selected person.
        slct_pers (int): person selected in that specific round.
        slct_status (str): selected person&#39;s status.

    Raises:
        warnings.warn: raise warning if neighbours have not the status of either
                                                    honests/lone wolves or criminals.

    Returns:
        Tuple[gt.Graph]: return the population
    &#34;&#34;&#34;
    if slct_status == &#34;h&#34;:
        # No victimizer -&gt;  No punishment
        return network

    # Get the status proportions of the group
    _, _, _, p_c, p_h, _ = self.counting_status_proportions(network, group_members)

    # If victimizer is found, penalties shouldn&#39;t 0.
    # state investigation
    state_penalty = self.conducting_investigation(
        group_members, slct_pers, self.beta_s
    )
    # civil investigation
    civil_penalty = (
        self.conducting_investigation(group_members, slct_pers, self.beta_h) * p_h
    )
    # criminal investigation
    criminal_penalty = (
        self.conducting_investigation(group_members, slct_pers, self.beta_c) * p_c
    )

    if slct_status == &#34;c&#34;:
        # only punish a wolf if he dared to act
        if self.criminal_acting is True:
            # Punish the victimizer
            network.fitness[slct_pers] = (
                network.fitness[slct_pers] - state_penalty - civil_penalty
            )
            # Punish the partner in crime
            for member in group_members:
                if network.status[member] == &#34;c&#34; and member != slct_pers:
                    network.fitness[member] = network.fitness[
                        member
                    ] - self.gamma * (state_penalty + civil_penalty)

    elif slct_status == &#34;w&#34;:
        # only punish a wolf if he dared to act
        if self.wolf_acting is True:
            # Punish the victimizer
            network.fitness[slct_pers] = (
                network.fitness[slct_pers]
                - state_penalty
                - civil_penalty
                - criminal_penalty
            )

    else:
        raise warnings.warn(&#34;slct_status should be either h/w/c...&#34;)

    return network</code></pre>
</details>
</dd>
<dt id="simulators.sim_mart_vaq.SimMartVaq.mutation"><code class="name flex">
<span>def <span class="ident">mutation</span></span>(<span>self, network: graph_tool.Graph, person: int) ‑> graph_tool.Graph</span>
</code></dt>
<dd>
<div class="desc"><p>Perform mutation on a given individual.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>network</code></strong> :&ensp;<code>gt.Graph</code></dt>
<dd>population with honests,lone wolves and criminals</dd>
<dt><strong><code>person</code></strong> :&ensp;<code>int</code></dt>
<dd>person selected in that round.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>gt.Graph</code></dt>
<dd>returns population.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mutation(self, network: gt.Graph, person: int) -&gt; gt.Graph:
    &#34;&#34;&#34;Perform mutation on a given individual.

    Args:
        network (gt.Graph): population with honests,lone wolves and criminals
        person (int): person selected in that round.

    Returns:
        gt.Graph: returns population.
    &#34;&#34;&#34;
    network.status[person] = random.choice([&#34;c&#34;, &#34;h&#34;, &#34;w&#34;])
    return network</code></pre>
</details>
</dd>
<dt id="simulators.sim_mart_vaq.SimMartVaq.play"><code class="name flex">
<span>def <span class="ident">play</span></span>(<span>self, network: graph_tool.Graph, rounds: int = 1, n_groups: int = 1, ith_collect: int = 20, collect_fitness: bool = True, measure_topology: bool = False, measure_likelihood_corr: bool = False, show_no_bar: bool = True, rnd_fit_init: bool = False) ‑> Tuple[graph_tool.Graph, DefaultDict[str, List[Any]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Play the agent-based model.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>network</code></strong> :&ensp;<code>gt.Graph</code></dt>
<dd>population including honests,lone actors and criminals.</dd>
<dt><strong><code>rounds</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>number of rounds to play. Defaults to 1.</dd>
<dt><strong><code>n_groups</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>each round select how many people are selected from the pool.
Defaults to 1.</dd>
<dt><strong><code>ith_collect</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>collect ratio every nth round (for speed improvement).
Defaults to 20.</dd>
<dt><strong><code>collect_fitness</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>collect fitness. Defaults to True.</dd>
<dt><strong><code>measure_topology</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>collect secrecy,flow of information and giant comp.
Defaults to False.</dd>
<dt><strong><code>measure_likelihood_corr</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>collect the likelihood of a node to be
criminal. Defaults to False.</dd>
<dt><strong><code>show_no_bar</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>show progress bar or not. Defaults to True.</dd>
<dt><strong><code>rnd_fit_init</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>assign random fitness to nodes. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[gt.Graph, DefaultDict[str, List[Any]]]</code></dt>
<dd>returns population and dictionary
containing all the measurements.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def play(
    self,
    network: gt.Graph,
    rounds: int = 1,
    n_groups: int = 1,
    ith_collect: int = 20,
    collect_fitness: bool = True,
    measure_topology: bool = False,
    measure_likelihood_corr: bool = False,
    show_no_bar: bool = True,
    rnd_fit_init: bool = False,
) -&gt; Tuple[gt.Graph, DefaultDict[str, List[Any]]]:
    &#34;&#34;&#34;Play the agent-based model.

    Args:
        network (gt.Graph): population including honests,lone actors and criminals.
        rounds (int, optional): number of rounds to play. Defaults to 1.
        n_groups (int, optional): each round select how many people are selected from the pool.
                                Defaults to 1.
        ith_collect (int, optional): collect ratio every nth round (for speed improvement).
                                    Defaults to 20.
        collect_fitness (bool, optional): collect fitness. Defaults to True.
        measure_topology (bool, optional): collect secrecy,flow of information and giant comp.
                                    Defaults to False.
        measure_likelihood_corr (bool, optional): collect the likelihood of a node to be
                                                    criminal. Defaults to False.
        show_no_bar (bool, optional): show progress bar or not. Defaults to True.
        rnd_fit_init (bool, optional): assign random fitness to nodes. Defaults to False.

    Returns:
        Tuple[gt.Graph, DefaultDict[str, List[Any]]]: returns population and dictionary
                                                            containing all the measurements.
    &#34;&#34;&#34;
    network.status = np.asarray(list(network.vp.status))
    if rnd_fit_init:
        network.fitness = np.random.uniform(50, -50, network.num_vertices())
    else:
        network.fitness = np.zeros(network.num_vertices())
    network.age = np.zeros(network.num_vertices())

    # collectors which collects the ratio and fitness over each iteration
    data_collector = defaultdict(
        list,
        {
            k: []
            for k in (
                &#34;ratio_honest&#34;,
                &#34;ratio_criminal&#34;,
                &#34;ratio_wolf&#34;,
                &#34;fitness_honest&#34;,
                &#34;fitness_criminal&#34;,
                &#34;fitness_wolf&#34;,
                &#34;secrecy&#34;,
                &#34;flow_information&#34;,
                &#34;size_of_largest_component&#34;,
                &#34;df&#34;,
            )
        },
    )  # type: DefaultDict[str, List[Any]]

    # Run the simulation
    for i in tqdm(
        range(1, rounds + 1),
        desc=&#34;Playing the rounds...&#34;,
        total=rounds,
        leave=False,
        disable=False,
    ):
        # Divide the network in random new groups
        dict_of_group = self.slct_pers_n_neighbours(
            network=network, n_groups=n_groups, network_size=network.num_vertices()
        )

        # Go through each group
        for slct_pers, group_members in dict_of_group.items():

            # Check the person status
            slct_pers_status = network.status[slct_pers]

            # Acting stage
            network, slct_pers, slct_status = self.acting_stage(
                network, slct_pers, slct_pers_status, group_members
            )
            # Investigation stage
            network = self.investigation_stage(
                network, group_members, slct_pers, slct_status
            )

        # Divide the network in random new groups for evolutionary process
        dict_of_group_evol = self.slct_pers_n_neighbours(
            network=network,
            n_groups=n_groups,
            network_size=network.num_vertices(),
        )
        # Go through each group
        for slct_pers_evol, group_members_evol in dict_of_group_evol.items():
            # Evolutionary stage
            network = self.evolutionary_stage(
                network, slct_pers_evol, group_members_evol
            )

        if measure_likelihood_corr:
            network = self.update_age(network)

        # update fitness decay
        network = self.update_fitness(network)

        # Collect the data
        if i % ith_collect == 0 or i == 1:
            _, _, _, p_c, p_h, p_w = self.counting_status_proportions(
                network=network,
                group_members=list(range(0, network.num_vertices())),
            )

            data_collector[&#34;iteration&#34;].append(i)
            data_collector[&#34;ratio_honest&#34;].append(p_h)
            data_collector[&#34;ratio_wolf&#34;].append(p_w)
            data_collector[&#34;ratio_criminal&#34;].append(p_c)

            if collect_fitness:
                (
                    mean_h_fit,
                    mean_c_fit,
                    mean_w_fit,
                ) = self.get_overall_fitness_distribution(network=network)
                data_collector[&#34;fitness_honest&#34;].append(mean_h_fit)
                data_collector[&#34;fitness_criminal&#34;].append(mean_c_fit)
                data_collector[&#34;fitness_wolf&#34;].append(mean_w_fit)

            if measure_topology:
                # Extract the criminal network, the filtering is done on the network object
                logger.info(&#34;Filtering the criminal_network&#34;)
                NetworkExtractor.filter_criminal_network(network)

                if network.num_vertices() == 0:
                    logger.info(&#34;No criminals in the network&#34;)
                    logger.info(&#34;Calculating the secrecy&#34;)
                    data_collector[&#34;secrecy&#34;].append(-1)
                    data_collector[&#34;density&#34;].append(0)
                    logger.info(&#34;Calculating the flow of information&#34;)
                    data_collector[&#34;flow_information&#34;].append(0)
                    logger.info(&#34;Calculating the largest_component&#34;)
                    data_collector[&#34;size_of_largest_component&#34;].append(0)

                elif network.num_vertices() &gt;= 1:
                    logger.info(&#34;Calculating the secrecy&#34;)
                    data_collector[&#34;secrecy&#34;].append(NodeStats.get_secrecy(network))
                    data_collector[&#34;density&#34;].append(NodeStats.get_density(network))
                    logger.info(&#34;Calculating the flow of information&#34;)

                    gsc = gt.extract_largest_component(network)
                    if self.execute == &#34;parallel&#34;:
                        data_collector[&#34;flow_information&#34;].append(
                            NodeStats.get_flow_of_information(gsc)
                        )
                    elif self.execute == &#34;sequential&#34;:
                        # the faster version doesn&#39;t work sequentially
                        data_collector[&#34;flow_information&#34;].append(
                            NodeStats.get_flow_of_information_faster(gsc)
                        )

                    logger.info(&#34;Calculating the largest_component&#34;)
                    data_collector[&#34;size_of_largest_component&#34;].append(
                        NodeStats.get_size_of_largest_component(network)[0]
                    )

                # Unfilter the network back to its initial configuration
                logger.info(&#34;UnFiltering the criminal_network&#34;)
                NetworkExtractor.un_filter_criminal_network(network)

    # Add a df with the likelihood of being a criminal and the node centrality
    if measure_likelihood_corr:
        data_collector[&#34;df&#34;] = self.create_likelihood_corr_df(network)

    gc.collect()
    return network, data_collector</code></pre>
</details>
</dd>
<dt id="simulators.sim_mart_vaq.SimMartVaq.slct_pers_n_neighbours"><code class="name flex">
<span>def <span class="ident">slct_pers_n_neighbours</span></span>(<span>self, network: graph_tool.Graph, n_groups: int, network_size: int) ‑> Dict[int, List[int]]</span>
</code></dt>
<dd>
<div class="desc"><p>Randomly select the protagonist (person who can act) and its neighbours.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>n_groups</code></strong> :&ensp;<code>int</code></dt>
<dd>number of groups to form each round</dd>
<dt><strong><code>network_size</code></strong> :&ensp;<code>int</code></dt>
<dd>get the size of the network to include all the nodes</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[int,List[int]]</code></dt>
<dd>key is the protagonist and value is protagonist + neighbors</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slct_pers_n_neighbours(
    self, network: gt.Graph, n_groups: int, network_size: int
) -&gt; Dict[int, List[int]]:
    &#34;&#34;&#34;Randomly select the protagonist (person who can act) and its neighbours.

    Args:
        n_groups (int): number of groups to form each round
        network_size (int): get the size of the network to include all the nodes

    Returns:
        Dict[int,List[int]]: key is the protagonist and value is protagonist + neighbors
    &#34;&#34;&#34;
    communities = {}
    protagonists = random.sample(range(0, network_size), n_groups)
    for protagonist in protagonists:
        communities[protagonist] = [protagonist] + list(
            network.get_all_neighbors(protagonist)
        )

    return communities</code></pre>
</details>
</dd>
<dt id="simulators.sim_mart_vaq.SimMartVaq.update_age"><code class="name flex">
<span>def <span class="ident">update_age</span></span>(<span>self, network: graph_tool.Graph) ‑> graph_tool.Graph</span>
</code></dt>
<dd>
<div class="desc"><p>Update the age of a criminal node.</p>
<p>Basically, count how many rounds a node has a criminal status criminal</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_age(self, network: gt.Graph) -&gt; gt.Graph:
    &#34;&#34;&#34;Update the age of a criminal node.

    Basically, count how many rounds a node has a criminal status criminal
    &#34;&#34;&#34;
    idx = np.where(network.status == &#34;c&#34;)
    network.age[idx] = network.age[idx] + 1
    return network</code></pre>
</details>
</dd>
<dt id="simulators.sim_mart_vaq.SimMartVaq.update_fitness"><code class="name flex">
<span>def <span class="ident">update_fitness</span></span>(<span>self, network: graph_tool.Graph) ‑> graph_tool.Graph</span>
</code></dt>
<dd>
<div class="desc"><p>Update the fitness in a decay fashion.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_fitness(self, network: gt.Graph) -&gt; gt.Graph:
    &#34;&#34;&#34;Update the fitness in a decay fashion.&#34;&#34;&#34;
    network.fitness = network.fitness * 0.666
    return network</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="simulators" href="index.html">simulators</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="simulators.sim_mart_vaq.SimMartVaq" href="#simulators.sim_mart_vaq.SimMartVaq">SimMartVaq</a></code></h4>
<ul class="">
<li><code><a title="simulators.sim_mart_vaq.SimMartVaq.acting_stage" href="#simulators.sim_mart_vaq.SimMartVaq.acting_stage">acting_stage</a></code></li>
<li><code><a title="simulators.sim_mart_vaq.SimMartVaq.avg_play" href="#simulators.sim_mart_vaq.SimMartVaq.avg_play">avg_play</a></code></li>
<li><code><a title="simulators.sim_mart_vaq.SimMartVaq.avg_play_help" href="#simulators.sim_mart_vaq.SimMartVaq.avg_play_help">avg_play_help</a></code></li>
<li><code><a title="simulators.sim_mart_vaq.SimMartVaq.conducting_investigation" href="#simulators.sim_mart_vaq.SimMartVaq.conducting_investigation">conducting_investigation</a></code></li>
<li><code><a title="simulators.sim_mart_vaq.SimMartVaq.counting_status_proportions" href="#simulators.sim_mart_vaq.SimMartVaq.counting_status_proportions">counting_status_proportions</a></code></li>
<li><code><a title="simulators.sim_mart_vaq.SimMartVaq.create_likelihood_corr_df" href="#simulators.sim_mart_vaq.SimMartVaq.create_likelihood_corr_df">create_likelihood_corr_df</a></code></li>
<li><code><a title="simulators.sim_mart_vaq.SimMartVaq.evolutionary_stage" href="#simulators.sim_mart_vaq.SimMartVaq.evolutionary_stage">evolutionary_stage</a></code></li>
<li><code><a title="simulators.sim_mart_vaq.SimMartVaq.fermi_function" href="#simulators.sim_mart_vaq.SimMartVaq.fermi_function">fermi_function</a></code></li>
<li><code><a title="simulators.sim_mart_vaq.SimMartVaq.get_overall_fitness_distribution" href="#simulators.sim_mart_vaq.SimMartVaq.get_overall_fitness_distribution">get_overall_fitness_distribution</a></code></li>
<li><code><a title="simulators.sim_mart_vaq.SimMartVaq.inflict_damage" href="#simulators.sim_mart_vaq.SimMartVaq.inflict_damage">inflict_damage</a></code></li>
<li><code><a title="simulators.sim_mart_vaq.SimMartVaq.interchange_roles" href="#simulators.sim_mart_vaq.SimMartVaq.interchange_roles">interchange_roles</a></code></li>
<li><code><a title="simulators.sim_mart_vaq.SimMartVaq.investigation_stage" href="#simulators.sim_mart_vaq.SimMartVaq.investigation_stage">investigation_stage</a></code></li>
<li><code><a title="simulators.sim_mart_vaq.SimMartVaq.mutation" href="#simulators.sim_mart_vaq.SimMartVaq.mutation">mutation</a></code></li>
<li><code><a title="simulators.sim_mart_vaq.SimMartVaq.name" href="#simulators.sim_mart_vaq.SimMartVaq.name">name</a></code></li>
<li><code><a title="simulators.sim_mart_vaq.SimMartVaq.play" href="#simulators.sim_mart_vaq.SimMartVaq.play">play</a></code></li>
<li><code><a title="simulators.sim_mart_vaq.SimMartVaq.slct_pers_n_neighbours" href="#simulators.sim_mart_vaq.SimMartVaq.slct_pers_n_neighbours">slct_pers_n_neighbours</a></code></li>
<li><code><a title="simulators.sim_mart_vaq.SimMartVaq.update_age" href="#simulators.sim_mart_vaq.SimMartVaq.update_age">update_age</a></code></li>
<li><code><a title="simulators.sim_mart_vaq.SimMartVaq.update_fitness" href="#simulators.sim_mart_vaq.SimMartVaq.update_fitness">update_fitness</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
