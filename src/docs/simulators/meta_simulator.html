<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>simulators.meta_simulator API documentation</title>
<meta name="description" content="This script contains the MetaSimulator â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>simulators.meta_simulator</code></h1>
</header>
<section id="section-intro">
<p>This script contains the MetaSimulator.</p>
<p>The MetaSimulator encapsules the simulation.
It prepares the network for the simulators, creates the population,
saves/load populations and calls the simulation to be played.
From this script, the different models can be run.</p>
<p><strong>author</strong> = Louis Weyland
<strong>date</strong> = 17/05/2022</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;This script contains the MetaSimulator.

The MetaSimulator encapsules the simulation.
It prepares the network for the simulators, creates the population,
saves/load populations and calls the simulation to be played.
From this script, the different models can be run.

__author__ = Louis Weyland
__date__ = 17/05/2022
&#34;&#34;&#34;
import itertools
import logging
import multiprocessing
import os
import random
import re
from copy import deepcopy
from typing import Any
from typing import DefaultDict
from typing import List
from typing import Tuple
from typing import Union

import graph_tool.all as gt
import numpy as np
import tqdm
from network_utils.network_combiner import NetworkCombiner
from network_utils.network_converter import NetworkConverter
from network_utils.network_reader import NetworkReader
from simulators.sim_mart_vaq import SimMartVaq
from utils.tools import DirectoryFinder
from utils.tools import timestamp


logger = logging.getLogger(&#34;logger&#34;)


class MetaSimulator:
    &#34;&#34;&#34;Encapsule all the simulations and prepares the network for it.&#34;&#34;&#34;

    def __init__(
        self,
        network_name: str,
        attachment_method: str,
        ratio_honest: float = 0.7,
        ratio_wolf: float = 0.1,
        k: int = 2,
        prob: float = 0.4,
        random_fit_init: bool = False,
    ) -&gt; None:
        &#34;&#34;&#34;Take all the necessary arguments to create a population.

        Args:
            network_name (str): name of the data to be loaded.
            attachment_method (str): define the attachment method to build the population.
            ratio_honest (float, optional): ratio of honest civilians in the population.
                                            Defaults to 0.7.
            ratio_wolf (float, optional): ratio of lone wolves in the population.
                                        Defaults to 0.1.
            k (int, optional): number of links a new nodes comes with.
                            Defaults to 2.
            prob (float, optional): rewiring probability for small-world attachment.
                                    Defaults to 0.4.
            random_fit_init (bool, optional): define if nodes get a random fitness initialisation.
                                        Defaults to False.
        &#34;&#34;&#34;
        # Define name of simulator
        self._name = &#34;meta_simulator&#34;
        self.attachment_method = attachment_method

        # Check if data is coherent
        assert 0 &lt; ratio_honest &lt; 1, &#34;Ratio needs to be (0,1)&#34;
        assert 0 &lt; ratio_wolf &lt; 1, &#34;Ratio needs to be (0,1)&#34;
        assert 0 &lt; ratio_wolf + ratio_honest &lt; 1, &#34;Together the ratio should be (0,1)&#34;

        self.ratio_honest = ratio_honest
        self.ratio_wolf = ratio_wolf
        self.ratio_criminal = 1 - self.ratio_honest - self.ratio_wolf

        self.criminal_network = self.prepare_network(network_name)
        self.network_name = self.criminal_network.gp.name

        # Network needs to have a base criminal network
        self.n_criminal = len(
            gt.find_vertex(self.criminal_network, self.criminal_network.vp.status, &#34;c&#34;)
        )
        (
            self.new_nodes,
            self.total_number_nodes,
            self.relative_ratio_honest,
            self.relative_ratio_wolf,
        ) = self.compute_the_ratio(self.n_criminal)

        # network property
        self.k = k
        self.prob = prob
        self.random_fit_init = random_fit_init

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;Return the name of the simulator.&#34;&#34;&#34;
        return self._name

    @property
    def network(self) -&gt; gt.Graph:
        &#34;&#34;&#34;Create a graph if called.&#34;&#34;&#34;
        return self.create_population(self.criminal_network)

    def prepare_network(self, network_name: str) -&gt; gt.Graph:
        &#34;&#34;&#34;Get the network.&#34;&#34;&#34;
        # Get actual criminal network
        nx_network = NetworkReader().get_data(network_name)
        logger.info(f&#34;The data used is {nx_network.name}&#34;)

        # Convert to gt.Graph
        gt_network = NetworkConverter.nx_to_gt(nx_network)
        assert gt_network.vp.status, &#34;Network has no attribute status&#34;
        return gt_network

    def create_population(self, network: gt.Graph) -&gt; gt.Graph:
        &#34;&#34;&#34;Create the population.

        Args:
            network (gt.Graph): criminal network w/o honests and lone wolves nodes.

        Returns:
            gt.Graph: returns populations incl. honests and lone wolves.
        &#34;&#34;&#34;
        # Add the new nodes
        np.random.seed()
        network = self.initialise_network(network, self.prob, self.k)
        return network

    def compute_the_ratio(self, n_criminal: int) -&gt; Tuple[int, int, float, float]:
        &#34;&#34;&#34;Compute the number of nodes to add given the number of criminals.

        Additionally computes the relative ratio for wolfs and honest to be added.
        &#34;&#34;&#34;
        # Network needs to have a base criminal network
        assert n_criminal &gt;= 1, &#34;The given network contains no criminals...&#34;

        total_number_nodes = int(n_criminal / self.ratio_criminal)
        new_nodes = total_number_nodes - n_criminal

        # Init either honest or lone wolf
        relative_ratio_honest = self.ratio_honest / (
            self.ratio_honest + self.ratio_wolf
        )
        relative_ratio_wolf = 1 - relative_ratio_honest
        return new_nodes, total_number_nodes, relative_ratio_honest, relative_ratio_wolf

    def initialise_network(
        self, network: gt.Graph, prob: float = 0.3, k: int = 2
    ) -&gt; gt.Graph:
        &#34;&#34;&#34;Add to the existing criminal network honest and lone wolfs.

        Thereby, the nodes are added based on the preferential attachment principle.
        Returns a network with new added nodes respecting the ratio of criminals/honest/wolfs.

        Args:
            network (gt.Graph): criminal network without honests and lone wolves.
            prob (float, optional): rewiring probability (for small-world). Defaults to 0.3.
            k (int, optional): number of link new added nodes come with. Defaults to 2.

        Raises:
            RuntimeError: raises error if attachment method is not preferential/random/small-world.

        Returns:
            gt.Graph: returns a population with honests and lone wolves.
        &#34;&#34;&#34;
        new_network = deepcopy(network)
        if self.attachment_method == &#34;preferential&#34;:
            new_network = NetworkCombiner.combine_by_preferential_attachment_faster(
                new_network, new_nodes=self.new_nodes, k=k
            )[0]
        elif self.attachment_method == &#34;random&#34;:
            new_network = NetworkCombiner.combine_by_random_attachment_faster(
                new_network, new_nodes=self.new_nodes, k=k
            )[0]
        elif self.attachment_method == &#34;small-world&#34;:
            new_network = NetworkCombiner.combine_by_small_world_attachment(
                new_network, new_nodes=self.new_nodes, k=k, prob=prob
            )[0]
        else:
            raise RuntimeError(
                &#34;Define a network attachment method : &#39;preferential&#39;,&#39;random&#39;,&#39;small-world&#39;&#34;
            )

        # Get all the agents with no status
        nodes_no_status = gt.find_vertex(new_network, new_network.vp.status, &#34;&#34;)
        tq = tqdm.tqdm(
            nodes_no_status,
            desc=&#34;Adding attributes to nodes&#34;,
            total=self.new_nodes,
            leave=False,
            disable=True,
        )
        for i in tq:
            new_network.vp.status[new_network.vertex(i)] = np.random.choice(
                [&#34;h&#34;, &#34;w&#34;], 1, p=[self.relative_ratio_honest, self.relative_ratio_wolf]
            )[0]

        return new_network

    def create_list_of_populations(self, repetition: int) -&gt; List[gt.Graph]:
        &#34;&#34;&#34;Create a list of n different populations.

        Args:
            repetition (int): number of populations to create.

        Returns:
            List[gt.Graph]: list of populations.
        &#34;&#34;&#34;
        list_of_population = []
        num_cpus = multiprocessing.cpu_count() - 1
        with multiprocessing.Pool(num_cpus) as p:
            for population in tqdm.tqdm(
                p.imap(
                    self.create_population,
                    itertools.repeat(deepcopy(self.criminal_network), repetition),
                ),
                total=repetition,
                desc=&#34;Creating populations....&#34;,
            ):
                list_of_population.append(self.create_population(self.criminal_network))

                p.close()
                p.join()
        return list_of_population

    def create_network_and_save(self, repetition: int) -&gt; None:
        &#34;&#34;&#34;Create a list of populations and saves it in the folder.

        Args:
            repetition (int): number of populations to create.
        &#34;&#34;&#34;
        population_name = (
            DirectoryFinder().population_data_dir
            + f&#34;{self.attachment_method}_h_{self.ratio_honest:.2f}_w_{self.ratio_wolf:.2f}_k_{self.k}&#34;
        )
        list_of_population = self.create_list_of_populations(repetition)
        for population in list_of_population:
            population.save(population_name + &#34;_&#34; + timestamp() + &#34;_graph.xml.gz&#34;)

    def load_list_of_populations(
        self, repetition: int, matching_files: List[str]
    ) -&gt; List[gt.Graph]:
        &#34;&#34;&#34;Load the created populations and return repetition amount of populations.

        The populations are randomly loaded from the files matching the description
        Args:
            repetition (int): number of populations to load.
            matching_files (List[str]): load the files matching the proportions of
                                                honest/lone wolves and number of links.

        Returns:
            List[gt.Graph]: _description_
        &#34;&#34;&#34;
        list_of_populations = random.choices(matching_files, k=repetition)

        list_of_loaded_population = []
        for population in list_of_populations:
            list_of_loaded_population.append(
                gt.load_graph(DirectoryFinder().population_data_dir + population)
            )
        return list_of_loaded_population

    def avg_play(
        self,
        rounds: int = 1,
        n_groups: int = 20,
        ith_collect: int = 20,
        repetition: int = 20,
        measure_topology: bool = False,
        measure_likelihood_corr: bool = False,
        collect_fitness: bool = False,
        execute: str = &#34;parallel&#34;,
        show_no_bar: bool = False,
        rnd_fit_init: bool = False,
    ) -&gt; DefaultDict[str, Union[DefaultDict[Any, Any], List[Any]]]:
        &#34;&#34;&#34;Get the average results of the simulation given the parameters.

        This function calls the SimMartVaq play function.
        Same as the avg_play function from sim_mart_vaq.py
        The difference is that instead of running the simulation n (number of repetition) times
        on the same network, the simulation is run once on n (number of repetition) networks

        Args:
            rounds (int, optional): number of rounds to play. Defaults to 1.
            n_groups (int, optional): number of nodes to choose each round. Defaults to 20.
            ith_collect (int, optional): collect the ratio every ith round. Defaults to 20.
            repetition (int, optional): number of repeating the simulation. Defaults to 20.
            measure_topology (bool, optional): to measure the secrecy,flow of info and giant comp.
                                                Defaults to False.
            measure_likelihood_corr (bool, optional): to measure the criminal likelihood.
                                                        Defaults to False.
            collect_fitness (bool, optional): to collect the fitness. Defaults to False.
            execute (str, optional): define to run the execution parallel or sequential.
                                                        Defaults to &#34;parallel&#34;.
            show_no_bar (bool, optional): to show the progress bar. Defaults to False.
            rnd_fit_init (bool, optional): assign random fitness to the agents. Defaults to False.

        Returns:
            DefaultDict[str, Union[DefaultDict[Any, Any], List[Any]]]: return a dict of the
                                            measurements of each repetition and the mean values.
        &#34;&#34;&#34;
        # create n different populations
        if len(
            [
                file
                for file in os.listdir(DirectoryFinder().population_data_dir)
                if re.search(self.attachment_method, file)
            ]
        ):

            all_files = [
                file
                for file in os.listdir(DirectoryFinder().population_data_dir)
                if re.search(self.attachment_method, file)
            ]
            matches = [f&#34;h_{self.ratio_honest}&#34;, f&#34;w_{self.ratio_wolf}&#34;, f&#34;k_{self.k}&#34;]
            matching_files = [
                file for file in all_files if all(word in file for word in matches)
            ]
            if len(matching_files) != 0:
                list_of_population = self.load_list_of_populations(
                    repetition, matching_files
                )
            elif len(matching_files) == 0:
                logger.info(&#34;No exisiting networks could be loaded&#34;)
                list_of_population = self.create_list_of_populations(repetition)

        else:
            logger.info(&#34;No exisiting networks could be loaded&#34;)
            list_of_population = self.create_list_of_populations(repetition)

        # init simulator and use a place holder population
        simulator = SimMartVaq(list_of_population[0], execute=execute)

        data_collector = simulator.avg_play(
            list_of_population,
            rounds=rounds,
            n_groups=n_groups,
            ith_collect=ith_collect,
            repetition=repetition,
            measure_topology=measure_topology,
            measure_likelihood_corr=measure_likelihood_corr,
            collect_fitness=collect_fitness,
            show_no_bar=show_no_bar,
            rnd_fit_init=rnd_fit_init,
        )
        return data_collector</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="simulators.meta_simulator.MetaSimulator"><code class="flex name class">
<span>class <span class="ident">MetaSimulator</span></span>
<span>(</span><span>network_name:Â str, attachment_method:Â str, ratio_honest:Â floatÂ =Â 0.7, ratio_wolf:Â floatÂ =Â 0.1, k:Â intÂ =Â 2, prob:Â floatÂ =Â 0.4, random_fit_init:Â boolÂ =Â False)</span>
</code></dt>
<dd>
<div class="desc"><p>Encapsule all the simulations and prepares the network for it.</p>
<p>Take all the necessary arguments to create a population.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>network_name</code></strong> :&ensp;<code>str</code></dt>
<dd>name of the data to be loaded.</dd>
<dt><strong><code>attachment_method</code></strong> :&ensp;<code>str</code></dt>
<dd>define the attachment method to build the population.</dd>
<dt><strong><code>ratio_honest</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>ratio of honest civilians in the population.
Defaults to 0.7.</dd>
<dt><strong><code>ratio_wolf</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>ratio of lone wolves in the population.
Defaults to 0.1.</dd>
<dt><strong><code>k</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>number of links a new nodes comes with.
Defaults to 2.</dd>
<dt><strong><code>prob</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>rewiring probability for small-world attachment.
Defaults to 0.4.</dd>
<dt><strong><code>random_fit_init</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>define if nodes get a random fitness initialisation.
Defaults to False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MetaSimulator:
    &#34;&#34;&#34;Encapsule all the simulations and prepares the network for it.&#34;&#34;&#34;

    def __init__(
        self,
        network_name: str,
        attachment_method: str,
        ratio_honest: float = 0.7,
        ratio_wolf: float = 0.1,
        k: int = 2,
        prob: float = 0.4,
        random_fit_init: bool = False,
    ) -&gt; None:
        &#34;&#34;&#34;Take all the necessary arguments to create a population.

        Args:
            network_name (str): name of the data to be loaded.
            attachment_method (str): define the attachment method to build the population.
            ratio_honest (float, optional): ratio of honest civilians in the population.
                                            Defaults to 0.7.
            ratio_wolf (float, optional): ratio of lone wolves in the population.
                                        Defaults to 0.1.
            k (int, optional): number of links a new nodes comes with.
                            Defaults to 2.
            prob (float, optional): rewiring probability for small-world attachment.
                                    Defaults to 0.4.
            random_fit_init (bool, optional): define if nodes get a random fitness initialisation.
                                        Defaults to False.
        &#34;&#34;&#34;
        # Define name of simulator
        self._name = &#34;meta_simulator&#34;
        self.attachment_method = attachment_method

        # Check if data is coherent
        assert 0 &lt; ratio_honest &lt; 1, &#34;Ratio needs to be (0,1)&#34;
        assert 0 &lt; ratio_wolf &lt; 1, &#34;Ratio needs to be (0,1)&#34;
        assert 0 &lt; ratio_wolf + ratio_honest &lt; 1, &#34;Together the ratio should be (0,1)&#34;

        self.ratio_honest = ratio_honest
        self.ratio_wolf = ratio_wolf
        self.ratio_criminal = 1 - self.ratio_honest - self.ratio_wolf

        self.criminal_network = self.prepare_network(network_name)
        self.network_name = self.criminal_network.gp.name

        # Network needs to have a base criminal network
        self.n_criminal = len(
            gt.find_vertex(self.criminal_network, self.criminal_network.vp.status, &#34;c&#34;)
        )
        (
            self.new_nodes,
            self.total_number_nodes,
            self.relative_ratio_honest,
            self.relative_ratio_wolf,
        ) = self.compute_the_ratio(self.n_criminal)

        # network property
        self.k = k
        self.prob = prob
        self.random_fit_init = random_fit_init

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;Return the name of the simulator.&#34;&#34;&#34;
        return self._name

    @property
    def network(self) -&gt; gt.Graph:
        &#34;&#34;&#34;Create a graph if called.&#34;&#34;&#34;
        return self.create_population(self.criminal_network)

    def prepare_network(self, network_name: str) -&gt; gt.Graph:
        &#34;&#34;&#34;Get the network.&#34;&#34;&#34;
        # Get actual criminal network
        nx_network = NetworkReader().get_data(network_name)
        logger.info(f&#34;The data used is {nx_network.name}&#34;)

        # Convert to gt.Graph
        gt_network = NetworkConverter.nx_to_gt(nx_network)
        assert gt_network.vp.status, &#34;Network has no attribute status&#34;
        return gt_network

    def create_population(self, network: gt.Graph) -&gt; gt.Graph:
        &#34;&#34;&#34;Create the population.

        Args:
            network (gt.Graph): criminal network w/o honests and lone wolves nodes.

        Returns:
            gt.Graph: returns populations incl. honests and lone wolves.
        &#34;&#34;&#34;
        # Add the new nodes
        np.random.seed()
        network = self.initialise_network(network, self.prob, self.k)
        return network

    def compute_the_ratio(self, n_criminal: int) -&gt; Tuple[int, int, float, float]:
        &#34;&#34;&#34;Compute the number of nodes to add given the number of criminals.

        Additionally computes the relative ratio for wolfs and honest to be added.
        &#34;&#34;&#34;
        # Network needs to have a base criminal network
        assert n_criminal &gt;= 1, &#34;The given network contains no criminals...&#34;

        total_number_nodes = int(n_criminal / self.ratio_criminal)
        new_nodes = total_number_nodes - n_criminal

        # Init either honest or lone wolf
        relative_ratio_honest = self.ratio_honest / (
            self.ratio_honest + self.ratio_wolf
        )
        relative_ratio_wolf = 1 - relative_ratio_honest
        return new_nodes, total_number_nodes, relative_ratio_honest, relative_ratio_wolf

    def initialise_network(
        self, network: gt.Graph, prob: float = 0.3, k: int = 2
    ) -&gt; gt.Graph:
        &#34;&#34;&#34;Add to the existing criminal network honest and lone wolfs.

        Thereby, the nodes are added based on the preferential attachment principle.
        Returns a network with new added nodes respecting the ratio of criminals/honest/wolfs.

        Args:
            network (gt.Graph): criminal network without honests and lone wolves.
            prob (float, optional): rewiring probability (for small-world). Defaults to 0.3.
            k (int, optional): number of link new added nodes come with. Defaults to 2.

        Raises:
            RuntimeError: raises error if attachment method is not preferential/random/small-world.

        Returns:
            gt.Graph: returns a population with honests and lone wolves.
        &#34;&#34;&#34;
        new_network = deepcopy(network)
        if self.attachment_method == &#34;preferential&#34;:
            new_network = NetworkCombiner.combine_by_preferential_attachment_faster(
                new_network, new_nodes=self.new_nodes, k=k
            )[0]
        elif self.attachment_method == &#34;random&#34;:
            new_network = NetworkCombiner.combine_by_random_attachment_faster(
                new_network, new_nodes=self.new_nodes, k=k
            )[0]
        elif self.attachment_method == &#34;small-world&#34;:
            new_network = NetworkCombiner.combine_by_small_world_attachment(
                new_network, new_nodes=self.new_nodes, k=k, prob=prob
            )[0]
        else:
            raise RuntimeError(
                &#34;Define a network attachment method : &#39;preferential&#39;,&#39;random&#39;,&#39;small-world&#39;&#34;
            )

        # Get all the agents with no status
        nodes_no_status = gt.find_vertex(new_network, new_network.vp.status, &#34;&#34;)
        tq = tqdm.tqdm(
            nodes_no_status,
            desc=&#34;Adding attributes to nodes&#34;,
            total=self.new_nodes,
            leave=False,
            disable=True,
        )
        for i in tq:
            new_network.vp.status[new_network.vertex(i)] = np.random.choice(
                [&#34;h&#34;, &#34;w&#34;], 1, p=[self.relative_ratio_honest, self.relative_ratio_wolf]
            )[0]

        return new_network

    def create_list_of_populations(self, repetition: int) -&gt; List[gt.Graph]:
        &#34;&#34;&#34;Create a list of n different populations.

        Args:
            repetition (int): number of populations to create.

        Returns:
            List[gt.Graph]: list of populations.
        &#34;&#34;&#34;
        list_of_population = []
        num_cpus = multiprocessing.cpu_count() - 1
        with multiprocessing.Pool(num_cpus) as p:
            for population in tqdm.tqdm(
                p.imap(
                    self.create_population,
                    itertools.repeat(deepcopy(self.criminal_network), repetition),
                ),
                total=repetition,
                desc=&#34;Creating populations....&#34;,
            ):
                list_of_population.append(self.create_population(self.criminal_network))

                p.close()
                p.join()
        return list_of_population

    def create_network_and_save(self, repetition: int) -&gt; None:
        &#34;&#34;&#34;Create a list of populations and saves it in the folder.

        Args:
            repetition (int): number of populations to create.
        &#34;&#34;&#34;
        population_name = (
            DirectoryFinder().population_data_dir
            + f&#34;{self.attachment_method}_h_{self.ratio_honest:.2f}_w_{self.ratio_wolf:.2f}_k_{self.k}&#34;
        )
        list_of_population = self.create_list_of_populations(repetition)
        for population in list_of_population:
            population.save(population_name + &#34;_&#34; + timestamp() + &#34;_graph.xml.gz&#34;)

    def load_list_of_populations(
        self, repetition: int, matching_files: List[str]
    ) -&gt; List[gt.Graph]:
        &#34;&#34;&#34;Load the created populations and return repetition amount of populations.

        The populations are randomly loaded from the files matching the description
        Args:
            repetition (int): number of populations to load.
            matching_files (List[str]): load the files matching the proportions of
                                                honest/lone wolves and number of links.

        Returns:
            List[gt.Graph]: _description_
        &#34;&#34;&#34;
        list_of_populations = random.choices(matching_files, k=repetition)

        list_of_loaded_population = []
        for population in list_of_populations:
            list_of_loaded_population.append(
                gt.load_graph(DirectoryFinder().population_data_dir + population)
            )
        return list_of_loaded_population

    def avg_play(
        self,
        rounds: int = 1,
        n_groups: int = 20,
        ith_collect: int = 20,
        repetition: int = 20,
        measure_topology: bool = False,
        measure_likelihood_corr: bool = False,
        collect_fitness: bool = False,
        execute: str = &#34;parallel&#34;,
        show_no_bar: bool = False,
        rnd_fit_init: bool = False,
    ) -&gt; DefaultDict[str, Union[DefaultDict[Any, Any], List[Any]]]:
        &#34;&#34;&#34;Get the average results of the simulation given the parameters.

        This function calls the SimMartVaq play function.
        Same as the avg_play function from sim_mart_vaq.py
        The difference is that instead of running the simulation n (number of repetition) times
        on the same network, the simulation is run once on n (number of repetition) networks

        Args:
            rounds (int, optional): number of rounds to play. Defaults to 1.
            n_groups (int, optional): number of nodes to choose each round. Defaults to 20.
            ith_collect (int, optional): collect the ratio every ith round. Defaults to 20.
            repetition (int, optional): number of repeating the simulation. Defaults to 20.
            measure_topology (bool, optional): to measure the secrecy,flow of info and giant comp.
                                                Defaults to False.
            measure_likelihood_corr (bool, optional): to measure the criminal likelihood.
                                                        Defaults to False.
            collect_fitness (bool, optional): to collect the fitness. Defaults to False.
            execute (str, optional): define to run the execution parallel or sequential.
                                                        Defaults to &#34;parallel&#34;.
            show_no_bar (bool, optional): to show the progress bar. Defaults to False.
            rnd_fit_init (bool, optional): assign random fitness to the agents. Defaults to False.

        Returns:
            DefaultDict[str, Union[DefaultDict[Any, Any], List[Any]]]: return a dict of the
                                            measurements of each repetition and the mean values.
        &#34;&#34;&#34;
        # create n different populations
        if len(
            [
                file
                for file in os.listdir(DirectoryFinder().population_data_dir)
                if re.search(self.attachment_method, file)
            ]
        ):

            all_files = [
                file
                for file in os.listdir(DirectoryFinder().population_data_dir)
                if re.search(self.attachment_method, file)
            ]
            matches = [f&#34;h_{self.ratio_honest}&#34;, f&#34;w_{self.ratio_wolf}&#34;, f&#34;k_{self.k}&#34;]
            matching_files = [
                file for file in all_files if all(word in file for word in matches)
            ]
            if len(matching_files) != 0:
                list_of_population = self.load_list_of_populations(
                    repetition, matching_files
                )
            elif len(matching_files) == 0:
                logger.info(&#34;No exisiting networks could be loaded&#34;)
                list_of_population = self.create_list_of_populations(repetition)

        else:
            logger.info(&#34;No exisiting networks could be loaded&#34;)
            list_of_population = self.create_list_of_populations(repetition)

        # init simulator and use a place holder population
        simulator = SimMartVaq(list_of_population[0], execute=execute)

        data_collector = simulator.avg_play(
            list_of_population,
            rounds=rounds,
            n_groups=n_groups,
            ith_collect=ith_collect,
            repetition=repetition,
            measure_topology=measure_topology,
            measure_likelihood_corr=measure_likelihood_corr,
            collect_fitness=collect_fitness,
            show_no_bar=show_no_bar,
            rnd_fit_init=rnd_fit_init,
        )
        return data_collector</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="simulators.meta_simulator.MetaSimulator.name"><code class="name">var <span class="ident">name</span> :Â str</code></dt>
<dd>
<div class="desc"><p>Return the name of the simulator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    &#34;&#34;&#34;Return the name of the simulator.&#34;&#34;&#34;
    return self._name</code></pre>
</details>
</dd>
<dt id="simulators.meta_simulator.MetaSimulator.network"><code class="name">var <span class="ident">network</span> :Â graph_tool.Graph</code></dt>
<dd>
<div class="desc"><p>Create a graph if called.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def network(self) -&gt; gt.Graph:
    &#34;&#34;&#34;Create a graph if called.&#34;&#34;&#34;
    return self.create_population(self.criminal_network)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="simulators.meta_simulator.MetaSimulator.avg_play"><code class="name flex">
<span>def <span class="ident">avg_play</span></span>(<span>self, rounds:Â intÂ =Â 1, n_groups:Â intÂ =Â 20, ith_collect:Â intÂ =Â 20, repetition:Â intÂ =Â 20, measure_topology:Â boolÂ =Â False, measure_likelihood_corr:Â boolÂ =Â False, collect_fitness:Â boolÂ =Â False, execute:Â strÂ =Â 'parallel', show_no_bar:Â boolÂ =Â False, rnd_fit_init:Â boolÂ =Â False) â€‘>Â DefaultDict[str,Â Union[DefaultDict[Any,Â Any],Â List[Any]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the average results of the simulation given the parameters.</p>
<p>This function calls the SimMartVaq play function.
Same as the avg_play function from sim_mart_vaq.py
The difference is that instead of running the simulation n (number of repetition) times
on the same network, the simulation is run once on n (number of repetition) networks</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rounds</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>number of rounds to play. Defaults to 1.</dd>
<dt><strong><code>n_groups</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>number of nodes to choose each round. Defaults to 20.</dd>
<dt><strong><code>ith_collect</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>collect the ratio every ith round. Defaults to 20.</dd>
<dt><strong><code>repetition</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>number of repeating the simulation. Defaults to 20.</dd>
<dt><strong><code>measure_topology</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>to measure the secrecy,flow of info and giant comp.
Defaults to False.</dd>
<dt><strong><code>measure_likelihood_corr</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>to measure the criminal likelihood.
Defaults to False.</dd>
<dt><strong><code>collect_fitness</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>to collect the fitness. Defaults to False.</dd>
<dt><strong><code>execute</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>define to run the execution parallel or sequential.
Defaults to "parallel".</dd>
<dt><strong><code>show_no_bar</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>to show the progress bar. Defaults to False.</dd>
<dt><strong><code>rnd_fit_init</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>assign random fitness to the agents. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DefaultDict[str, Union[DefaultDict[Any, Any], List[Any]]]</code></dt>
<dd>return a dict of the
measurements of each repetition and the mean values.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def avg_play(
    self,
    rounds: int = 1,
    n_groups: int = 20,
    ith_collect: int = 20,
    repetition: int = 20,
    measure_topology: bool = False,
    measure_likelihood_corr: bool = False,
    collect_fitness: bool = False,
    execute: str = &#34;parallel&#34;,
    show_no_bar: bool = False,
    rnd_fit_init: bool = False,
) -&gt; DefaultDict[str, Union[DefaultDict[Any, Any], List[Any]]]:
    &#34;&#34;&#34;Get the average results of the simulation given the parameters.

    This function calls the SimMartVaq play function.
    Same as the avg_play function from sim_mart_vaq.py
    The difference is that instead of running the simulation n (number of repetition) times
    on the same network, the simulation is run once on n (number of repetition) networks

    Args:
        rounds (int, optional): number of rounds to play. Defaults to 1.
        n_groups (int, optional): number of nodes to choose each round. Defaults to 20.
        ith_collect (int, optional): collect the ratio every ith round. Defaults to 20.
        repetition (int, optional): number of repeating the simulation. Defaults to 20.
        measure_topology (bool, optional): to measure the secrecy,flow of info and giant comp.
                                            Defaults to False.
        measure_likelihood_corr (bool, optional): to measure the criminal likelihood.
                                                    Defaults to False.
        collect_fitness (bool, optional): to collect the fitness. Defaults to False.
        execute (str, optional): define to run the execution parallel or sequential.
                                                    Defaults to &#34;parallel&#34;.
        show_no_bar (bool, optional): to show the progress bar. Defaults to False.
        rnd_fit_init (bool, optional): assign random fitness to the agents. Defaults to False.

    Returns:
        DefaultDict[str, Union[DefaultDict[Any, Any], List[Any]]]: return a dict of the
                                        measurements of each repetition and the mean values.
    &#34;&#34;&#34;
    # create n different populations
    if len(
        [
            file
            for file in os.listdir(DirectoryFinder().population_data_dir)
            if re.search(self.attachment_method, file)
        ]
    ):

        all_files = [
            file
            for file in os.listdir(DirectoryFinder().population_data_dir)
            if re.search(self.attachment_method, file)
        ]
        matches = [f&#34;h_{self.ratio_honest}&#34;, f&#34;w_{self.ratio_wolf}&#34;, f&#34;k_{self.k}&#34;]
        matching_files = [
            file for file in all_files if all(word in file for word in matches)
        ]
        if len(matching_files) != 0:
            list_of_population = self.load_list_of_populations(
                repetition, matching_files
            )
        elif len(matching_files) == 0:
            logger.info(&#34;No exisiting networks could be loaded&#34;)
            list_of_population = self.create_list_of_populations(repetition)

    else:
        logger.info(&#34;No exisiting networks could be loaded&#34;)
        list_of_population = self.create_list_of_populations(repetition)

    # init simulator and use a place holder population
    simulator = SimMartVaq(list_of_population[0], execute=execute)

    data_collector = simulator.avg_play(
        list_of_population,
        rounds=rounds,
        n_groups=n_groups,
        ith_collect=ith_collect,
        repetition=repetition,
        measure_topology=measure_topology,
        measure_likelihood_corr=measure_likelihood_corr,
        collect_fitness=collect_fitness,
        show_no_bar=show_no_bar,
        rnd_fit_init=rnd_fit_init,
    )
    return data_collector</code></pre>
</details>
</dd>
<dt id="simulators.meta_simulator.MetaSimulator.compute_the_ratio"><code class="name flex">
<span>def <span class="ident">compute_the_ratio</span></span>(<span>self, n_criminal:Â int) â€‘>Â Tuple[int,Â int,Â float,Â float]</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the number of nodes to add given the number of criminals.</p>
<p>Additionally computes the relative ratio for wolfs and honest to be added.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_the_ratio(self, n_criminal: int) -&gt; Tuple[int, int, float, float]:
    &#34;&#34;&#34;Compute the number of nodes to add given the number of criminals.

    Additionally computes the relative ratio for wolfs and honest to be added.
    &#34;&#34;&#34;
    # Network needs to have a base criminal network
    assert n_criminal &gt;= 1, &#34;The given network contains no criminals...&#34;

    total_number_nodes = int(n_criminal / self.ratio_criminal)
    new_nodes = total_number_nodes - n_criminal

    # Init either honest or lone wolf
    relative_ratio_honest = self.ratio_honest / (
        self.ratio_honest + self.ratio_wolf
    )
    relative_ratio_wolf = 1 - relative_ratio_honest
    return new_nodes, total_number_nodes, relative_ratio_honest, relative_ratio_wolf</code></pre>
</details>
</dd>
<dt id="simulators.meta_simulator.MetaSimulator.create_list_of_populations"><code class="name flex">
<span>def <span class="ident">create_list_of_populations</span></span>(<span>self, repetition:Â int) â€‘>Â List[graph_tool.Graph]</span>
</code></dt>
<dd>
<div class="desc"><p>Create a list of n different populations.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>repetition</code></strong> :&ensp;<code>int</code></dt>
<dd>number of populations to create.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[gt.Graph]</code></dt>
<dd>list of populations.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_list_of_populations(self, repetition: int) -&gt; List[gt.Graph]:
    &#34;&#34;&#34;Create a list of n different populations.

    Args:
        repetition (int): number of populations to create.

    Returns:
        List[gt.Graph]: list of populations.
    &#34;&#34;&#34;
    list_of_population = []
    num_cpus = multiprocessing.cpu_count() - 1
    with multiprocessing.Pool(num_cpus) as p:
        for population in tqdm.tqdm(
            p.imap(
                self.create_population,
                itertools.repeat(deepcopy(self.criminal_network), repetition),
            ),
            total=repetition,
            desc=&#34;Creating populations....&#34;,
        ):
            list_of_population.append(self.create_population(self.criminal_network))

            p.close()
            p.join()
    return list_of_population</code></pre>
</details>
</dd>
<dt id="simulators.meta_simulator.MetaSimulator.create_network_and_save"><code class="name flex">
<span>def <span class="ident">create_network_and_save</span></span>(<span>self, repetition:Â int) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Create a list of populations and saves it in the folder.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>repetition</code></strong> :&ensp;<code>int</code></dt>
<dd>number of populations to create.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_network_and_save(self, repetition: int) -&gt; None:
    &#34;&#34;&#34;Create a list of populations and saves it in the folder.

    Args:
        repetition (int): number of populations to create.
    &#34;&#34;&#34;
    population_name = (
        DirectoryFinder().population_data_dir
        + f&#34;{self.attachment_method}_h_{self.ratio_honest:.2f}_w_{self.ratio_wolf:.2f}_k_{self.k}&#34;
    )
    list_of_population = self.create_list_of_populations(repetition)
    for population in list_of_population:
        population.save(population_name + &#34;_&#34; + timestamp() + &#34;_graph.xml.gz&#34;)</code></pre>
</details>
</dd>
<dt id="simulators.meta_simulator.MetaSimulator.create_population"><code class="name flex">
<span>def <span class="ident">create_population</span></span>(<span>self, network:Â graph_tool.Graph) â€‘>Â graph_tool.Graph</span>
</code></dt>
<dd>
<div class="desc"><p>Create the population.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>network</code></strong> :&ensp;<code>gt.Graph</code></dt>
<dd>criminal network w/o honests and lone wolves nodes.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>gt.Graph</code></dt>
<dd>returns populations incl. honests and lone wolves.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_population(self, network: gt.Graph) -&gt; gt.Graph:
    &#34;&#34;&#34;Create the population.

    Args:
        network (gt.Graph): criminal network w/o honests and lone wolves nodes.

    Returns:
        gt.Graph: returns populations incl. honests and lone wolves.
    &#34;&#34;&#34;
    # Add the new nodes
    np.random.seed()
    network = self.initialise_network(network, self.prob, self.k)
    return network</code></pre>
</details>
</dd>
<dt id="simulators.meta_simulator.MetaSimulator.initialise_network"><code class="name flex">
<span>def <span class="ident">initialise_network</span></span>(<span>self, network:Â graph_tool.Graph, prob:Â floatÂ =Â 0.3, k:Â intÂ =Â 2) â€‘>Â graph_tool.Graph</span>
</code></dt>
<dd>
<div class="desc"><p>Add to the existing criminal network honest and lone wolfs.</p>
<p>Thereby, the nodes are added based on the preferential attachment principle.
Returns a network with new added nodes respecting the ratio of criminals/honest/wolfs.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>network</code></strong> :&ensp;<code>gt.Graph</code></dt>
<dd>criminal network without honests and lone wolves.</dd>
<dt><strong><code>prob</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>rewiring probability (for small-world). Defaults to 0.3.</dd>
<dt><strong><code>k</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>number of link new added nodes come with. Defaults to 2.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>raises error if attachment method is not preferential/random/small-world.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>gt.Graph</code></dt>
<dd>returns a population with honests and lone wolves.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialise_network(
    self, network: gt.Graph, prob: float = 0.3, k: int = 2
) -&gt; gt.Graph:
    &#34;&#34;&#34;Add to the existing criminal network honest and lone wolfs.

    Thereby, the nodes are added based on the preferential attachment principle.
    Returns a network with new added nodes respecting the ratio of criminals/honest/wolfs.

    Args:
        network (gt.Graph): criminal network without honests and lone wolves.
        prob (float, optional): rewiring probability (for small-world). Defaults to 0.3.
        k (int, optional): number of link new added nodes come with. Defaults to 2.

    Raises:
        RuntimeError: raises error if attachment method is not preferential/random/small-world.

    Returns:
        gt.Graph: returns a population with honests and lone wolves.
    &#34;&#34;&#34;
    new_network = deepcopy(network)
    if self.attachment_method == &#34;preferential&#34;:
        new_network = NetworkCombiner.combine_by_preferential_attachment_faster(
            new_network, new_nodes=self.new_nodes, k=k
        )[0]
    elif self.attachment_method == &#34;random&#34;:
        new_network = NetworkCombiner.combine_by_random_attachment_faster(
            new_network, new_nodes=self.new_nodes, k=k
        )[0]
    elif self.attachment_method == &#34;small-world&#34;:
        new_network = NetworkCombiner.combine_by_small_world_attachment(
            new_network, new_nodes=self.new_nodes, k=k, prob=prob
        )[0]
    else:
        raise RuntimeError(
            &#34;Define a network attachment method : &#39;preferential&#39;,&#39;random&#39;,&#39;small-world&#39;&#34;
        )

    # Get all the agents with no status
    nodes_no_status = gt.find_vertex(new_network, new_network.vp.status, &#34;&#34;)
    tq = tqdm.tqdm(
        nodes_no_status,
        desc=&#34;Adding attributes to nodes&#34;,
        total=self.new_nodes,
        leave=False,
        disable=True,
    )
    for i in tq:
        new_network.vp.status[new_network.vertex(i)] = np.random.choice(
            [&#34;h&#34;, &#34;w&#34;], 1, p=[self.relative_ratio_honest, self.relative_ratio_wolf]
        )[0]

    return new_network</code></pre>
</details>
</dd>
<dt id="simulators.meta_simulator.MetaSimulator.load_list_of_populations"><code class="name flex">
<span>def <span class="ident">load_list_of_populations</span></span>(<span>self, repetition:Â int, matching_files:Â List[str]) â€‘>Â List[graph_tool.Graph]</span>
</code></dt>
<dd>
<div class="desc"><p>Load the created populations and return repetition amount of populations.</p>
<p>The populations are randomly loaded from the files matching the description</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>repetition</code></strong> :&ensp;<code>int</code></dt>
<dd>number of populations to load.</dd>
<dt><strong><code>matching_files</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>load the files matching the proportions of
honest/lone wolves and number of links.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[gt.Graph]</code></dt>
<dd><em>description</em></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_list_of_populations(
    self, repetition: int, matching_files: List[str]
) -&gt; List[gt.Graph]:
    &#34;&#34;&#34;Load the created populations and return repetition amount of populations.

    The populations are randomly loaded from the files matching the description
    Args:
        repetition (int): number of populations to load.
        matching_files (List[str]): load the files matching the proportions of
                                            honest/lone wolves and number of links.

    Returns:
        List[gt.Graph]: _description_
    &#34;&#34;&#34;
    list_of_populations = random.choices(matching_files, k=repetition)

    list_of_loaded_population = []
    for population in list_of_populations:
        list_of_loaded_population.append(
            gt.load_graph(DirectoryFinder().population_data_dir + population)
        )
    return list_of_loaded_population</code></pre>
</details>
</dd>
<dt id="simulators.meta_simulator.MetaSimulator.prepare_network"><code class="name flex">
<span>def <span class="ident">prepare_network</span></span>(<span>self, network_name:Â str) â€‘>Â graph_tool.Graph</span>
</code></dt>
<dd>
<div class="desc"><p>Get the network.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepare_network(self, network_name: str) -&gt; gt.Graph:
    &#34;&#34;&#34;Get the network.&#34;&#34;&#34;
    # Get actual criminal network
    nx_network = NetworkReader().get_data(network_name)
    logger.info(f&#34;The data used is {nx_network.name}&#34;)

    # Convert to gt.Graph
    gt_network = NetworkConverter.nx_to_gt(nx_network)
    assert gt_network.vp.status, &#34;Network has no attribute status&#34;
    return gt_network</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="simulators" href="index.html">simulators</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="simulators.meta_simulator.MetaSimulator" href="#simulators.meta_simulator.MetaSimulator">MetaSimulator</a></code></h4>
<ul class="">
<li><code><a title="simulators.meta_simulator.MetaSimulator.avg_play" href="#simulators.meta_simulator.MetaSimulator.avg_play">avg_play</a></code></li>
<li><code><a title="simulators.meta_simulator.MetaSimulator.compute_the_ratio" href="#simulators.meta_simulator.MetaSimulator.compute_the_ratio">compute_the_ratio</a></code></li>
<li><code><a title="simulators.meta_simulator.MetaSimulator.create_list_of_populations" href="#simulators.meta_simulator.MetaSimulator.create_list_of_populations">create_list_of_populations</a></code></li>
<li><code><a title="simulators.meta_simulator.MetaSimulator.create_network_and_save" href="#simulators.meta_simulator.MetaSimulator.create_network_and_save">create_network_and_save</a></code></li>
<li><code><a title="simulators.meta_simulator.MetaSimulator.create_population" href="#simulators.meta_simulator.MetaSimulator.create_population">create_population</a></code></li>
<li><code><a title="simulators.meta_simulator.MetaSimulator.initialise_network" href="#simulators.meta_simulator.MetaSimulator.initialise_network">initialise_network</a></code></li>
<li><code><a title="simulators.meta_simulator.MetaSimulator.load_list_of_populations" href="#simulators.meta_simulator.MetaSimulator.load_list_of_populations">load_list_of_populations</a></code></li>
<li><code><a title="simulators.meta_simulator.MetaSimulator.name" href="#simulators.meta_simulator.MetaSimulator.name">name</a></code></li>
<li><code><a title="simulators.meta_simulator.MetaSimulator.network" href="#simulators.meta_simulator.MetaSimulator.network">network</a></code></li>
<li><code><a title="simulators.meta_simulator.MetaSimulator.prepare_network" href="#simulators.meta_simulator.MetaSimulator.prepare_network">prepare_network</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
